

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="mq">
  <meta name="keywords" content="">
  
    <meta name="description" content="BUAA 软院 大二上 OOP课程总结">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象程序设计-Java">
<meta property="og:url" content="http://authormq.github.io/2023/01/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java/index.html">
<meta property="og:site_name" content="Samuel&#39;s Blog">
<meta property="og:description" content="BUAA 软院 大二上 OOP课程总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java/%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B.png">
<meta property="article:published_time" content="2023-01-29T06:38:06.000Z">
<meta property="article:modified_time" content="2023-01-29T07:05:44.355Z">
<meta property="article:author" content="mq">
<meta property="article:tag" content="BUAA">
<meta property="article:tag" content="OO">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java/%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B.png">
  
  
  
  <title>面向对象程序设计-Java - Samuel&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"authormq.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Samuel&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/articalDefault.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面向对象程序设计-Java"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-29 14:38" pubdate>
          2023年1月29日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面向对象程序设计-Java</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：几秒前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>BUAA 软院 大二上 OOP课程总结</p>
<span id="more"></span>
<h1 id="面向对象程序设计-OOP"><a href="#面向对象程序设计-OOP" class="headerlink" title="面向对象程序设计(OOP)"></a>面向对象程序设计(OOP)</h1><h2 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h2><ul>
<li>两个基本概念：类(class)、对象(Object)</li>
</ul>
<ul>
<li>三大特征：封装、继承、多态</li>
</ul>
<h3 id="1、Java语言运行机制"><a href="#1、Java语言运行机制" class="headerlink" title="1、Java语言运行机制"></a>1、Java语言运行机制</h3><h4 id="1-1、JVM"><a href="#1-1、JVM" class="headerlink" title="1.1、JVM"></a>1.1、JVM</h4><p>Java 虚拟机是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。对于不同的平台有着不同的 JVM，只有某平台提供了对应的 Java 虚拟机，Java 程序才可以在这个平台上运行。</p>
<p>JVM 屏蔽底层运行平台的差别，可以实现<strong>“一次编译，到处运行“</strong></p>
<h4 id="1-2、Garbage-Collection"><a href="#1-2、Garbage-Collection" class="headerlink" title="1.2、Garbage Collection"></a>1.2、Garbage Collection</h4><p>Java 消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间.</p>
<p><strong>Tips：</strong>Java 程序即使可以实现垃圾的自动回收，但是依旧会出现内存泄漏和内存溢出问题。</p>
<p>但在Java中，依旧提供了<strong>内存强制回收机制</strong>。</p>
<p>Java 系统提供了方法<code>System.gc()</code>和<code>Runtime.gc()</code> 方法来强制立即回收垃圾(<strong>但系统并不保证会立即进行垃圾回收</strong>)。</p>
<p>判断一个存储单元是否是垃圾的依据：<strong>该存储单元所对应的对象是否仍被程序所用</strong>。而判断一个对象是否仍为程序所用的依据是：<strong>是否有引用指向该对象</strong>。</p>
<h3 id="2、对象"><a href="#2、对象" class="headerlink" title="2、对象"></a>2、对象</h3><ul>
<li>对象的特征：属性</li>
</ul>
<ul>
<li>属性是对象具有的各种特征，且每个对象的各个属性都具有特定值。</li>
</ul>
<ul>
<li>对象的动作：方法</li>
</ul>
<ul>
<li>对象执行的操作称之为方法</li>
</ul>
<h2 id="二、封装数据为类"><a href="#二、封装数据为类" class="headerlink" title="二、封装数据为类"></a>二、封装数据为类</h2><p>Java 允许在一个Java 源文件中编写多个类，但其中的多个类至多只能有一个类使用 public 修饰，并且这个类一般含有 main 方法。</p>
<h3 id="1、类的定义说明"><a href="#1、类的定义说明" class="headerlink" title="1、类的定义说明"></a>1、类的定义说明</h3><ul>
<li>关键字<code>class</code>表示类定义的开始</li>
<li>类名要符合标识符的命名规范</li>
<li>修饰符分为访问控制符和类型说明符<ul>
<li>类的访问控制符只有两个：<code>public</code>和默认</li>
<li>一个类被定义为公共类，那么它可以被其他所有的类访问和引用</li>
<li>不用<code>public</code>定义的类，只能被同一个包中定义的类访问和引用</li>
<li>类的类型说明符有两个：<code>final</code>和<code>abstract</code></li>
</ul>
</li>
</ul>
<h3 id="2、成员方法定义说明"><a href="#2、成员方法定义说明" class="headerlink" title="2、成员方法定义说明"></a>2、成员方法定义说明</h3><ul>
<li>常用修饰符：<code>public</code>、<code>private</code>、<code>protected</code>、<code>static</code>、<code>final</code></li>
</ul>
<h3 id="3、创建对象"><a href="#3、创建对象" class="headerlink" title="3、创建对象"></a>3、创建对象</h3><p>Java每个类都默认地具有<code>null</code>、<code>this</code>、<code>super</code>三个域，在任何类中都可以不加说明引用他们。</p>
<blockquote>
<p><code>null</code>：代表”空“，用在定义一个对象但没有为其开辟内存空间时。</p>
<p><code>this</code>&amp;<code>super</code>：指代<strong>本类对象</strong>和<strong>父类对象</strong>的关键字</p>
</blockquote>
<p><code>this</code>可以看作一个变量，它的值是当前对象的引用。在类的方法定义中，使用<code>this</code>关键字代表使用该方法的对象的引用。</p>
<p>使用<code>this</code>可以处理方法中成员变量和局部变量重名的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//example</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4、深拷贝和浅拷贝"><a href="#4、深拷贝和浅拷贝" class="headerlink" title="4、深拷贝和浅拷贝"></a>4、深拷贝和浅拷贝</h3><p><strong>浅拷贝</strong>：浅拷贝是会将对象的每一个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时，也会跟着改变。</p>
<p><strong>深拷贝</strong>：深拷贝复制变量值，对于引用数据，则递归至基本类型后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>
<blockquote>
<p><strong>基本类型</strong>作为参数传递 -&gt; 深拷贝</p>
<p><strong>引用类型</strong>作为参数传递 -&gt; 浅拷贝</p>
</blockquote>
<h3 id="5、方法的重载"><a href="#5、方法的重载" class="headerlink" title="5、方法的重载"></a>5、方法的重载</h3><p>方法的重载：指一个类中有多个<strong>名字相同</strong>，但<strong>参数不同</strong>的方法。</p>
<blockquote>
<h5 id="重载方法必须满足的条件："><a href="#重载方法必须满足的条件：" class="headerlink" title="重载方法必须满足的条件："></a>重载方法必须满足的条件：</h5><ul>
<li><p>方法名相同</p>
</li>
<li><p>方法的参数的类型，个数，顺序至少有一个不同</p>
</li>
<li><p>方法的返回类型可以不相同</p>
</li>
<li><p>方法的修饰符可以不相同</p>
<p>关于参数列表的顺序，Tips:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//error:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> b, <span class="hljs-type">int</span> a)</span>&#123;&#125; <br><span class="hljs-comment">//虽然参数列表中的变量名不同，但类型相同，本质上就是(int, int);</span><br><span class="hljs-comment">//right:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b)</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">int</span> b)</span>&#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="6、构造方法"><a href="#6、构造方法" class="headerlink" title="6、构造方法"></a>6、构造方法</h3><p>构造方法：一类特殊的成员方法，用<code>new</code>关键字来对新生成的对象进行初始化。</p>
<blockquote>
<h5 id="构造方法必须满足的条件："><a href="#构造方法必须满足的条件：" class="headerlink" title="构造方法必须满足的条件："></a>构造方法必须满足的条件：</h5><ul>
<li>方法名与类同名</li>
<li>没有任何的返回值</li>
<li>语法结构与一般方法相同</li>
</ul>
</blockquote>
<p>一个类，至少会有一个构造方法，构造方法分为不带参数构造方法(<strong>默认构造方法</strong>)和带参数构造方法。</p>
<p>在使用构造方法时，会使用<code>new</code>关键字。其作用为：</p>
<blockquote>
<ul>
<li>为对象分配内存空间</li>
<li>引起对象构造方法的调用</li>
<li>为对象返回一个引用</li>
</ul>
</blockquote>
<p><strong>Tips:如果一个类没有显式的定义任何构造函数，系统将自动提供一个默认构造方法。该构造方法：没有参数，没有方法体。一旦在类中定义了一个构造函数，那么便不会自动提供一个默认构造方法。</strong></p>
<p><strong>构造方法也可以重载。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动提供的默认构造方法举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>即：如果类中提供的构造函数都不是无参数构造函数，却企图调用无参数构造函数初始化此类的对象，编译时会产生语法错误。</p>
<h3 id="7、对象构造顺序"><a href="#7、对象构造顺序" class="headerlink" title="7、对象构造顺序"></a>7、对象构造顺序</h3><p>用<code>new</code>语句创建类的对象时，Java虚拟机会从最上层的父类开始，依次执行各个父类以及当前类的构造方法，从而保证来自于对象本身以及从父类中继承的实例变量都被正确地初始化。即：<strong>先构造父类对象，再构造子类对象</strong>。</p>
<blockquote>
<ol>
<li>递归的构造父类对象</li>
<li>顺序地调用本类成员属性赋初值语句</li>
<li>本类的构造方法</li>
</ol>
</blockquote>
<h3 id="8、特殊的对象：匿名对象"><a href="#8、特殊的对象：匿名对象" class="headerlink" title="8、特殊的对象：匿名对象"></a>8、特殊的对象：匿名对象</h3><p>我们可以不定义对象的句柄，直接调用对象的方法，这样的对象叫做<strong>匿名对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匿名对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">//定义了一个对象，但是没有名字，称为匿名对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>().show(); <span class="hljs-comment">//匿名对象的方法的调用</span><br></code></pre></td></tr></table></figure>
<p><strong>Tips:匿名对象用完了之后就变成垃圾了，因为这个对象没有被栈内存中的变量指向，所以会被<code>gc</code>回收。</strong></p>
<p>匿名对象常作为一个实参传递给一个函数调用。</p>
<h3 id="9、类的访问机制以及类中变量的存储"><a href="#9、类的访问机制以及类中变量的存储" class="headerlink" title="9、类的访问机制以及类中变量的存储"></a>9、类的访问机制以及类中变量的存储</h3><blockquote>
<p><strong>在一个类中的访问机制：</strong>类中的方法可以直接访问类中的成员变量。</p>
<p><strong>在不同类中的访问机制：</strong>先创建访问类的对象，再用对象访问类中的成员变量。</p>
</blockquote>
<p>类中的变量分为：成员变量和局部变量</p>
<p><strong>成员变量</strong>存储在<strong>堆</strong>内存的对象中，所有成员变量<strong>具有默认的初始化值</strong>。</p>
<p><strong>局部变量</strong>存储在<strong>栈</strong>内存的对象中，局部变量<strong>没有默认的初始化值</strong>，必须<strong>手动赋值</strong>才可以使用。</p>
<h3 id="10、类的静态属性和静态方法（重点、难点）"><a href="#10、类的静态属性和静态方法（重点、难点）" class="headerlink" title="10、类的静态属性和静态方法（重点、难点）"></a>10、类的静态属性和静态方法（重点、难点）</h3><hr>
<p>程序运行时的内存占用：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码区（code area）</th>
<th style="text-align:center">存放程序的代码部分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据区（data area）</td>
<td style="text-align:center">存放数据的全局数据和静态数据</td>
</tr>
<tr>
<td style="text-align:center">堆区（heap area）</td>
<td style="text-align:center">存放程序动态申请的数据</td>
</tr>
<tr>
<td style="text-align:center">栈区（stack area）</td>
<td style="text-align:center">存放程序的局部数据和参数</td>
</tr>
</tbody>
</table>
</div>
<p>在Java中，把<strong>代表类范围信息</strong>的变量和方法用<code>static</code>修饰。</p>
<p>当你把某一个变量或者方法用<code>static</code>修饰，它就不再局限于所属的<code>class Object</code>上了，即使没有创建该类的具体对象，类中的static类成员也会存在。</p>
<blockquote>
<ul>
<li>用<code>static</code>修饰的属性/变量称为静态属性/类变量</li>
<li>用<code>static</code>修饰的方法称为静态方法/类方法。<strong>在类方法里没有<code>this</code></strong></li>
<li>用<code>static</code>修饰的初始化语句块称为静态初始化语句块</li>
</ul>
</blockquote>
<p>静态方法和非静态方法的区别：</p>
<blockquote>
<ul>
<li>本质区别：静态方法在<strong>类定义时</strong>已经被装载和分配的（早加载）；而非静态方法在类定义是时没有占用内存，只有在<strong>类被实例化成对象时</strong>，对象调用该方法才被分配内存（晚加载）。</li>
<li>静态方法中只能调用静态成员和静态方法，不能调用非静态成员和非静态方法。非静态方法要被实例化才能被静态方法调用。</li>
</ul>
</blockquote>
<p><code>new</code>一个对象的语句执行顺序：</p>
<blockquote>
<h5 id="第一次new该类对象时："><a href="#第一次new该类对象时：" class="headerlink" title="第一次new该类对象时："></a>第一次<code>new</code>该类对象时：</h5><ul>
<li>初始化有显式初始化的 static 成员变量</li>
<li>按顺序执行 static 语句块</li>
<li>初始化有显式初始化的非 static 成员变量</li>
<li>按顺序执行非 static 语句块</li>
<li>调用构造函数</li>
</ul>
<h5 id="第二次再次new该类对象是："><a href="#第二次再次new该类对象是：" class="headerlink" title="第二次再次new该类对象是："></a>第二次再次<code>new</code>该类对象是：</h5><ul>
<li>初始化有显式初始化的非 static 成员变量</li>
<li>按照顺序执行非 static 语句块</li>
<li>调用构造函数</li>
</ul>
</blockquote>
<p>静态代码块只能定义在类里面，它独立于任何方法，不能定义在方法里面。</p>
<h2 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h2><p>“隐藏属性、方法或实现细节过程称为封装。”</p>
<blockquote>
<h5 id="Java中封装的体现："><a href="#Java中封装的体现：" class="headerlink" title="Java中封装的体现："></a>Java中封装的体现：</h5><ul>
<li>访问权限修饰符</li>
<li>类</li>
<li>package</li>
<li>系统</li>
</ul>
</blockquote>
<h3 id="1、访问控制修饰符"><a href="#1、访问控制修饰符" class="headerlink" title="1、访问控制修饰符"></a>1、访问控制修饰符</h3><p>访问控制修饰符分为四个级别：</p>
<ul>
<li><strong>公开级别</strong>：用<code>public</code>修饰，对外公开。</li>
<li><strong>受保护级别</strong>：用<code>protected</code>修饰，向子类以及同一个包中的类公开。</li>
<li><strong>默认级别</strong>：没有访问控制修饰符，向同一个包中的类公开。</li>
<li><strong>私有级别</strong>：用<code>private</code>修饰，只有类本身可以访问，不对外公开。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">同一个类</th>
<th style="text-align:center">同一个包</th>
<th style="text-align:center">子类</th>
<th style="text-align:center">整体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>private</strong></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>default</strong></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>protected</strong></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>public</strong></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<h5 id="关于protected修饰符的注意事项："><a href="#关于protected修饰符的注意事项：" class="headerlink" title="关于protected修饰符的注意事项："></a>关于protected修饰符的注意事项：</h5><ul>
<li>父类的<code>protected</code>成员<strong>是包内可见的，并且对子类可见。</strong></li>
<li>若子类和父类<strong>不在同一个包</strong>中，那么在子类中，<strong>子类实例可以访问其从父类继承而来的<code>protected</code>方法，而不能访问父类实例的<code>protected</code>方法</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//superClass:</span><br><span class="hljs-keyword">package</span> test_protected.superclass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-comment">//subClass:</span><br><span class="hljs-keyword">package</span> test_protected.subclass;<br><span class="hljs-keyword">import</span> test_protected.superclass.Father;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//子类实例访问从父类继承的protected属性和方法</span><br>        a = <span class="hljs-number">1</span>; <span class="hljs-comment">//正确</span><br>        test(); <span class="hljs-comment">//正确</span><br>        <span class="hljs-comment">//访问父类实例的protected属性和方法</span><br>        <span class="hljs-type">Father</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br>        f.a = <span class="hljs-number">1</span>; <span class="hljs-comment">//编译错误</span><br>        f.test(); <span class="hljs-comment">//编译错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>对于<code>protected</code>修饰的静态变量，<strong>无论是否同一个包，在子类中均可直接访问</strong>。</li>
<li>在不同包下，在子类中<strong>不能</strong>通过<strong>另一个子类引用</strong>访问<strong>共同基类的<code>protected</code>方法</strong>。</li>
</ul>
</blockquote>
<h3 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h3><p><strong>单例类</strong>指<strong>仅有一个实例</strong>的类。</p>
<blockquote>
<h5 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h5><ul>
<li>只需要使用一个单独的资源，并且需要共享这个单独资源的信息时，使用单例模式。</li>
<li>需要频繁的的进行创建和销毁对象。</li>
<li>创建对象时耗时过多或耗费资源过多，但又经常使用到的对象。</li>
<li>工具类对象。</li>
<li>频繁访问数据库或文件的对象。</li>
</ul>
</blockquote>
<h4 id="2-1、“饿汉式”单例模式"><a href="#2-1、“饿汉式”单例模式" class="headerlink" title="2.1、“饿汉式”单例模式"></a>2.1、“饿汉式”单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态的，保留自身的引用，类加载时就初始化。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">//必须是私有的构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">//公共的静态的方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<h5 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h5><ul>
<li>没有Lazy初始化，但是具有多线程安全。</li>
<li>优点：没有加锁，执行效率会更高。</li>
<li>缺点：类加载时就初始化，容易产生垃圾，浪费内存。</li>
</ul>
</blockquote>
<h4 id="2-2、“懒汉式”单例模式"><a href="#2-2、“懒汉式”单例模式" class="headerlink" title="2.2、“懒汉式”单例模式"></a>2.2、“懒汉式”单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态的，保留自身的引用。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//必须是私有的构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">//公共的静态的方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<h5 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h5><ul>
<li>进行 Lazy 初始化，但是多线程不安全。</li>
<li>若想要线程安全，需要加锁(<code>synchronized</code>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>)<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、继承-inheritance"><a href="#四、继承-inheritance" class="headerlink" title="四、继承(inheritance)"></a>四、继承(inheritance)</h2><p>继承是一种<code>is-a</code>的关系，但并不是所有<code>is-a</code>的关系都可以写成继承。</p>
<p>Java<strong>只允许单继承</strong>，不允许多继承。</p>
<blockquote>
<h5 id="子类-subClass-从父类-superClass-那里继承的东西"><a href="#子类-subClass-从父类-superClass-那里继承的东西" class="headerlink" title="子类(subClass)从父类(superClass)那里继承的东西"></a>子类(subClass)从父类(superClass)那里继承的东西</h5><ul>
<li>子类拥有父类的所有的属性和方法。</li>
<li>子类可以对父类进行扩展。子类可以拥有自己的属性和方法。子类既可以<strong>重载</strong>父类的方法，也可以<strong>覆盖/重写</strong>父类的方法。</li>
</ul>
<p>但子类<strong>不能继承父类的构造方法</strong>。</p>
</blockquote>
<p>类继承的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符] class 类名 extends 父类名&#123;<br>	类体;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1、子类构造函数"><a href="#1、子类构造函数" class="headerlink" title="1、子类构造函数"></a>1、子类构造函数</h3><p>由于父类的构造函数不能被继承，所以子类需要编写构造函数。</p>
<blockquote>
<ul>
<li><h5 id="无参子类构造函数"><a href="#无参子类构造函数" class="headerlink" title="无参子类构造函数"></a>无参子类构造函数</h5><ul>
<li>子类可以通过<code>super()</code>显式调用父类无参的构造函数，也可以隐式调用。</li>
</ul>
</li>
<li><h5 id="有参子类构造函数"><a href="#有参子类构造函数" class="headerlink" title="有参子类构造函数"></a>有参子类构造函数</h5><ul>
<li>需要初始化父类的成员变量。</li>
<li>需要初始化子类的成员变量。</li>
<li>必须显式调用父类有参构造函数。</li>
</ul>
</li>
</ul>
<h5 id="TIPS：无论使用this调用本类构造函数，还是使用super调用父类构造函数，都必须是该方法体中的第一条可执行语句，否则会产生语法错误。"><a href="#TIPS：无论使用this调用本类构造函数，还是使用super调用父类构造函数，都必须是该方法体中的第一条可执行语句，否则会产生语法错误。" class="headerlink" title="TIPS：无论使用this调用本类构造函数，还是使用super调用父类构造函数，都必须是该方法体中的第一条可执行语句，否则会产生语法错误。"></a>TIPS：无论使用<code>this</code>调用本类构造函数，还是使用<code>super</code>调用父类构造函数，都必须是该方法体中的第一条可执行语句，否则会产生语法错误。</h5></blockquote>
<ul>
<li><h4 id="子类对象的构建"><a href="#子类对象的构建" class="headerlink" title="子类对象的构建"></a>子类对象的构建</h4><ul>
<li>子类创建对象时，子类的构造方法总是先调用父类的某个构造方法，完成父类部分的创建；然后再调用子类自己的构造方法，完成子类部分的创建。</li>
<li>如果子类的构造方法没有显式指明调用了父类的哪一构造方法，子类就调用父类的不带参数的构造方法。</li>
<li>子类在创建一个子类对象时，不仅为子类中声明得成员变量都分配了内存，而且父类的所有的成员变量也都分配了内存空间。</li>
</ul>
</li>
<li><h4 id="this和super用法"><a href="#this和super用法" class="headerlink" title="this和super用法"></a><code>this</code>和<code>super</code>用法</h4><blockquote>
<ul>
<li><h5 id="this用于："><a href="#this用于：" class="headerlink" title="this用于："></a><code>this</code>用于：</h5><ul>
<li>引用自身对象的成员变量：<code>this.age</code></li>
<li>引用自身对象的成员方法：<code>this.display()</code></li>
<li>调用自身的构造方法：<code>this(&quot;Jack&quot;, &quot;male&quot;, 10)</code></li>
</ul>
</li>
<li><h5 id="super用于："><a href="#super用于：" class="headerlink" title="super用于："></a><code>super</code>用于：</h5><ul>
<li>引用父类对象的成员变量：<code>super.age</code></li>
<li>引用父类对象的成员方法：<code>super.display()</code></li>
<li>引用父类的构造方法：<code>super(&quot;Jack&quot;, &quot;male&quot;, 10)</code></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="2、向上造型-upcasting"><a href="#2、向上造型-upcasting" class="headerlink" title="2、向上造型(upcasting)"></a>2、向上造型(upcasting)</h3><blockquote>
<p>详见多态</p>
</blockquote>
<h3 id="3、变量隐藏和方法覆盖"><a href="#3、变量隐藏和方法覆盖" class="headerlink" title="3、变量隐藏和方法覆盖"></a>3、变量隐藏和方法覆盖</h3><ul>
<li><h4 id="变量隐藏"><a href="#变量隐藏" class="headerlink" title="变量隐藏"></a>变量隐藏</h4><ul>
<li>在子类对父类的继承中，子类的成员变量和父类的成员变量同名，称此时子类<strong>隐藏</strong>(<code>override</code>)了父类的成员变量。</li>
<li>当发生变量隐藏后，子类若要引用父类的同名变量，要用<code>super</code>进行引用：<code>super.变量名</code>。</li>
</ul>
</li>
<li><h4 id="方法隐藏-方法覆盖"><a href="#方法隐藏-方法覆盖" class="headerlink" title="方法隐藏/方法覆盖"></a>方法隐藏/方法覆盖</h4><ul>
<li>方法覆盖就是子类的方法跟父类的方法具有完全一样的签名和参数（<strong>名称、参数、返回类型完全相同</strong>）。</li>
<li>方法覆盖在Java中属于动态联编（详见多态）。</li>
<li><strong>私有方法、静态方法不能被覆盖</strong>，如果在子类中出现了同签名的方法，称为<strong>方法隐藏</strong>。</li>
<li>用<code>final</code>声明的成员方法是<strong>最终方法</strong>，<strong>最终方法不能被子类覆盖（重写）</strong>。</li>
</ul>
</li>
</ul>
<h2 id="五、多态-polymorphism"><a href="#五、多态-polymorphism" class="headerlink" title="五、多态(polymorphism)"></a>五、多态(polymorphism)</h2><ul>
<li>多态有两种<ul>
<li><strong>静态多态性</strong>：包括方法的隐藏、方法的重载；在编译时决定调用哪个方法，即<strong>编译时的多态</strong>，也称为<strong>静态联编/静绑定</strong>。<ul>
<li><strong>Tips</strong>：静多态与是否发生继承<strong>没有</strong>必然联系。</li>
</ul>
</li>
<li><strong>动态多态性</strong>：在<strong>编译时不能确定要调用的方法</strong>，只有<strong>在运行时才能确定</strong>所要调用的方法。</li>
</ul>
</li>
</ul>
<h3 id="1、动多态"><a href="#1、动多态" class="headerlink" title="1、动多态"></a>1、动多态</h3><p>动态多态：在<strong>运行时</strong>确定调用的方法，也称为<strong>运行时多态、动态联编、动绑定</strong>。</p>
<ul>
<li>方法覆盖是指子类的成员方法重写了父类的成员方法，<strong>重写的目的很大程度上是为了实现多态</strong>。</li>
</ul>
<p><strong>Java 中，实现多态有3个条件：继承、覆盖、向上造型，缺一不可。</strong></p>
<blockquote>
<p>Java 形成动态多态必须具备的条件：</p>
<ul>
<li>必须要有<strong>继承</strong>的情况存在。</li>
<li>在继承中必须要有<strong>方法的覆盖</strong>。</li>
<li>必须<strong>由父类的引用指向派生类的实例</strong>，<strong>并且通过父类的引用调用被覆盖的方法</strong>。<ul>
<li>由父类的引用指向派生类的实例：<code>SuperClass superClass = new SubClass();</code></li>
<li>通过父类的引用调用被覆盖的方法：<code>superClass.f();</code></li>
</ul>
</li>
</ul>
<p>即<strong>继承是实现动多态的首要前提</strong>。</p>
</blockquote>
<h4 id="1-1、方法覆盖"><a href="#1-1、方法覆盖" class="headerlink" title="1.1、方法覆盖"></a>1.1、方法覆盖</h4><p>方法覆盖：要求方法名、参数个数、参数类型以及参数顺序必须一致。</p>
<p><strong>Tips：</strong>若父类方法定义时有异常抛出，则子类覆盖父类该方法时，该方法不能有更多的异常抛出，否则编译时会产生错误。</p>
<blockquote>
<h5 id="方法覆盖注意："><a href="#方法覆盖注意：" class="headerlink" title="方法覆盖注意："></a>方法覆盖注意：</h5><ul>
<li><p>子类方法<strong>不能缩小</strong>父类方法的<strong>访问权限</strong>。</p>
<ul>
<li><code>package</code>方法可以被写成<code>package</code>、<code>protected</code>、<code>public</code></li>
<li><code>protected</code>方法可以被写成<code>protected</code>、<code>public</code></li>
<li><code>public</code>方法只能被写成<code>public</code></li>
</ul>
<p><strong>PS：</strong>对于<strong>异常</strong>来说，<strong>不能扩大重写方法抛出的异常</strong>，这样会导致无法catch到。</p>
</li>
<li><p><strong>私有方法、静态方法</strong>不能被覆盖，如果在子类中出现了同签名的方法，就是方法隐藏。</p>
</li>
<li><p>父类中，<code>final</code>修饰的方法是最终方法，不允许覆盖。</p>
</li>
</ul>
</blockquote>
<h4 id="1-2、动多态注意事项"><a href="#1-2、动多态注意事项" class="headerlink" title="1.2、动多态注意事项"></a>1.2、动多态注意事项</h4><ul>
<li>子类的成员变量和父类同名，会出现<strong>变量隐藏</strong>的情况；子类“重写”父类的<code>private</code>或<code>static</code>函数，会出现<strong>函数隐藏</strong>的情况。<strong>用父类引用访问那个被隐藏的变量，只会访问父类的那个变量；用父类引用调用那个被隐藏的函数，只会调用父类的那个函数。</strong></li>
<li><strong>向上造型</strong>是通过父类的引用动态调用子类重写的方法，但是<strong>不能够访问子类新增的成员</strong>。此时可以通过<strong>强制转型（向下造型）</strong>来访问子类新增的成员，但<strong>具有一定的风险</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SuperClass::f()&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SubClass::f()&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">g</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SubClass::g()&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SuperClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br>        superClass.f(); <span class="hljs-comment">// 正确，输出 SubClass::f()</span><br>        superClass.g(); <span class="hljs-comment">// 错误</span><br>        <span class="hljs-type">SubClass</span> <span class="hljs-variable">subClass</span> <span class="hljs-operator">=</span> (SubClass) superClass;<br>        subClass.g(); <span class="hljs-comment">// 正确，但有⻛险，输出 SubClass::g()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="六、抽象-abstract"><a href="#六、抽象-abstract" class="headerlink" title="六、抽象(abstract)"></a>六、抽象(abstract)</h2><p>用关键字<code>abstract</code>修饰方法和类，表示抽象，有尚未实现的含义。</p>
<ul>
<li><p><strong>抽象类</strong>：用<code>abstract</code>修饰的类。</p>
<ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>普通的一个类，也可以用<code>abstract</code>修饰，但是没有实际意义。但是<strong>含有抽象函数的类必须用抽象类</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>抽象方法</strong>：用<code>abstract</code>修饰的方法。抽象方法<strong>没有方法体</strong>（没有方法体和方法体为空是两个不同的概念），格式为</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符] <span class="hljs-keyword">abstract</span> [返回值类型] 方法名(参数列表);<br><span class="hljs-comment">//eg:public abstract void print(); -&gt; 没有方法体，即没有大括号</span><br></code></pre></td></tr></table></figure>
<blockquote>
<h5 id="几点注意："><a href="#几点注意：" class="headerlink" title="几点注意："></a>几点注意：</h5><ul>
<li>抽象函数没有函数体。</li>
<li>抽象函数必须在抽象类中。</li>
<li>抽象函数必须在子类中被实现，除非子类也是抽象类。</li>
</ul>
</blockquote>
<h3 id="关于抽象类和抽象方法更多的细节："><a href="#关于抽象类和抽象方法更多的细节：" class="headerlink" title="关于抽象类和抽象方法更多的细节："></a>关于抽象类和抽象方法更多的细节：</h3><ul>
<li>抽象类一般使用在<strong>父类对象没有机会被访问调用，或者父类的函数很难明确的实现</strong>的情况下，适合使用抽象类。</li>
<li><strong>不能实例化抽象类</strong>，但是，可以通过抽象类的引用管理其子类，实现动态联编。</li>
<li><strong>含有抽象函数的类必须是抽象类</strong>。<ul>
<li>如果一个子类继承自某个抽象类，但是<strong>没有实现或者只实现了部分父类中的抽象函数</strong>，那么<strong>子类必须声明为抽象类</strong>。</li>
<li>当一个类声明实现了某个接口，但是<strong>没有实现或者只实现了该接口的部分的函数</strong>，则<strong>这个类必须声明为抽象类</strong>。</li>
<li><strong>一个抽象类中可以声明成员变量和函数</strong>，包括静态的类变量和类函数。</li>
</ul>
</li>
</ul>
<h2 id="七、接口-interface"><a href="#七、接口-interface" class="headerlink" title="七、接口(interface)"></a>七、接口(interface)</h2><p>接口是一种<strong>特殊的抽象类</strong>，在这个抽象类中，只<strong>包含常量和方法的定义</strong>，而<strong>没有方法的实现</strong>。即可以说：接口时抽象方法和常量值的定义的集合。</p>
<p>从语法上来看，接口与“类”很相似，只是<strong>接口中所有的方法都是抽象的</strong>。</p>
<blockquote>
<h5 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h5><ul>
<li>接口中所有的方法都默认是<code>public abstract</code>的，并且只有方法头和参数列表，没有方法体。</li>
<li>接口中所有的变量都默认是<code>public static final</code>的。</li>
<li>接口中没有构造方法。</li>
<li>一个类可以实现多个接口。（即 Java 通过这种方式来实现多继承）</li>
<li>用其他语言<code>(C, Python.etc)</code>书写接口时，接口方法需要用<code>native</code>关键字修饰。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口的定义和声明</span><br>[<span class="hljs-keyword">public</span>][interface]InterfaceName[<span class="hljs-keyword">extends</span> <span class="hljs-title class_">superInterfaces</span>]&#123;<br>    <span class="hljs-comment">//静态常量</span><br>    [<span class="hljs-keyword">public</span>][<span class="hljs-keyword">static</span>][<span class="hljs-keyword">final</span>]数据类型 变量名 = 常量名;<br>    <span class="hljs-comment">//抽象方法</span><br>    [<span class="hljs-keyword">public</span>][<span class="hljs-keyword">abstract</span>][<span class="hljs-keyword">native</span>]返回值类型 方法名（参数列表）;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现接口</span><br>[修饰符]<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>[<span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClassName</span>][implements 接口A, 接口B..]&#123;<br>    <span class="hljs-comment">//body</span><br>    <span class="hljs-comment">//类中的成员变量和成员方法</span><br>    <span class="hljs-comment">//为接口A中的所有方法编写方法体，实现接口A</span><br>    <span class="hljs-comment">//为接口B中的所有方法编写方法体，实现接口B</span><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h5><ul>
<li>一个类在实现接口的函数时，应采用完全相同的函数头，否则就只是重载一个新方法，而不是实现接口中的抽象方法。</li>
<li>接口的抽象函数访问权限是<code>public</code>，因此类在实现时，必须<strong>显式的使用</strong><code>public</code>修饰符，否则将被警告为缩小了接口中定义的方法的访问控制范围。</li>
</ul>
</blockquote>
<h3 id="1、接口的回调"><a href="#1、接口的回调" class="headerlink" title="1、接口的回调"></a>1、接口的回调</h3><p>接口回调：把实现某一接口的类创建的对象引用赋给该接口声明的接口变量该接口变量就可以调用被实现的接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">接口变量 = 实现该接口的类所创建的对象;<br>接口变量.接口方法([参数列表]);<br></code></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MyInterface.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&#123;<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MyClass.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>  	<span class="hljs-comment">//body</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br> 		<span class="hljs-type">MyInterface</span> <span class="hljs-variable">myInterface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>  		myInterface.f();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>Tips:</strong></p>
<ul>
<li><strong>用一个接口类型的引用去管理实现了该接口的类的实例化对象，那么就可以通过这个引用去调用接口中的那些函数。</strong></li>
<li>接口也可以作为<strong>函数的参数（函数传参）[声明时]</strong>，但<strong>实际传入的参数[调用时]</strong>是<strong>实现了该接口的类的对象的引用</strong>，那么<strong>接口参数就可以回调类实现的接口方法</strong>。</li>
</ul>
<h3 id="2、接口的继承"><a href="#2、接口的继承" class="headerlink" title="2、接口的继承"></a>2、接口的继承</h3><ul>
<li><p>接口可以像普通的类一样用关键词<code>extends</code>继承父接口，从而得到父接口中所有的成员。</p>
</li>
<li><p>接口中的函数在某一个实现该接口的类中，只能被书写一次。</p>
</li>
<li><p>不同接口（包括父子接口）中同名的变量相互隐藏，使用时应用<code>接口名.变量名</code>的形式明确指出。</p>
<ul>
<li><h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//In.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">In</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">In</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(a); <span class="hljs-comment">// 1</span><br>        System.out.println(In.a); <span class="hljs-comment">// 1</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>().b); <span class="hljs-comment">// 22</span><br>        System.out.println(In.b); <span class="hljs-comment">// 2</span><br>        System.out.println(c); <span class="hljs-comment">// 33</span><br>        System.out.println(In.c); <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><h4 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//In1.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">In1</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//In2.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">In2</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">In1</span>, In2 &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(a); <span class="hljs-comment">//错误，存在冲突</span><br>        System.out.println(In1.a); <span class="hljs-comment">// 1</span><br>        System.out.println(In2.a); <span class="hljs-comment">// 2</span><br>        <br>        System.out.println(b); <span class="hljs-comment">// 99</span><br>        System.out.println(In1.b); <span class="hljs-comment">// 11</span><br>        System.out.println(In2.b); <span class="hljs-comment">// 22</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3、instanceof"><a href="#3、instanceof" class="headerlink" title="3、instanceof"></a>3、<code>instanceof</code></h3><ul>
<li><p><strong>向上造型总是安全的。</strong>通过向上造型可以实现动多态，但是<strong>不能通过父类的引用访问子类新增的成员变量</strong>。</p>
</li>
<li><p><strong>向下造型是有风险的。</strong>如果不能进行转型，则会报出<strong>运行时错误</strong>，编译时无法确定。但向下造型的好处在于可以使用子类特有的功能。</p>
</li>
<li><p><code>instanceof</code>是一个<strong>二元运算符</strong>，用于判断一个引用类型所管理的对象是不是一个类的实例。左侧算子是一个<strong>引用类型的变量</strong>（可以是<code>null</code>），右侧的算子是一个<strong>类名或者接口名</strong>。运算符的结果是<code>boolean</code>类型的<code>true</code>或者<code>false</code>。</p>
</li>
<li><p><strong><code>instanceof</code>细节</strong></p>
<ul>
<li><p>表达式<code>A instanceof B</code>的值为<code>true</code>的情况包括</p>
<ul>
<li>引用<code>A</code>管理类<code>B</code>的对象</li>
<li><code>B</code>为<code>A</code>的直接或间接父类</li>
<li><code>B</code>为<code>A</code>实现的接口</li>
</ul>
</li>
<li><p><strong>强制转型</strong>，可能会发生<strong>编译错误</strong>，也有可能会<strong>抛出<code>ClassCastException</code></strong>。</p>
<ul>
<li><p>编译错误发生的情形</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 毫无关系的类之间进行强制转型。</span><br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)random;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用接口管理未实现该接口的final类</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> (list)integer;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用一个final类管理其未实现的接口</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)list;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>抛出<code>ClassCastException</code>的情形</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用子类管理父类（即使子类是final）</span><br>Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Integer&gt;();<br>Stack&lt;Integer&gt; stack = (Stack&lt;Integer&gt;)vector;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用接口管理未实现该接口的普通类</span><br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> (list)random;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用未实现某个接口的普通类管理该接口</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> (Random)list;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用一个接口管理另一个接口</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> (Runnable)list;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>当强制转换不能通过编译时，<code>instanceof</code>也不能通过编译；当强制转换会抛出异常时，<code>instanceof</code>返回<code>false</code>。如果<code>instanceof</code>左侧算子不为<code>null</code>，并且强制转换不抛出<code>ClassCastException</code>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="八、Java集合框架"><a href="#八、Java集合框架" class="headerlink" title="八、Java集合框架"></a>八、Java集合框架</h2><blockquote>
<ul>
<li><code>Collection</code>接口存储一组<strong>不唯一，无序</strong>的对象。</li>
<li><code>List</code>接口存储一组<strong>不唯一，有序（插入顺序）</strong>的对象。</li>
<li><code>Set</code>接口存储一组<strong>唯一，无序</strong>的对象。</li>
<li><code>Map</code>接口存储一组<strong>键值</strong>对象，提供<code>key</code>到<code>value</code>的映射。</li>
</ul>
</blockquote>
<p>Java 所有的集合类都位于<code>java.util</code>包下。Java 的集合类主要由两个接口派生而出：<code>Collection</code>和<code>Map</code>，<code>Collection</code>和<code>Map</code>是 Java 集合框架的根接口，这两个接口又包含了一些子接口或实现类。</p>
<ul>
<li>关于集合框架总体的一些说明<ul>
<li><code>Collection</code>接口是一组允许重复的对象。</li>
<li><code>Set</code>接口继承<code>Collection</code>，集合元素不重复。</li>
<li><code>List</code>接口继承<code>Collection</code>，允许重复，维护元素的插入顺序。</li>
<li><code>Map</code>接口时键值对象，与<code>Collection</code>接口没有什么关系。</li>
<li><code>Set</code>，<code>List</code>，<code>Map</code>可以看做集合的三大类：<ul>
<li><code>List</code>集合是有序集合，<strong>集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</strong></li>
<li><code>Set</code>集合是无序集合，<strong>集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。</strong></li>
<li><code>Map</code>集合中保存<code>Key-Vaule</code>对形式的元素，访问时只能根据每项元素的<code>key</code>来访问其<code>value</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1、Set接口实现类"><a href="#1、Set接口实现类" class="headerlink" title="1、Set接口实现类"></a>1、<code>Set</code>接口实现类</h3><p><code>Set</code>中的元素必须唯一，并且添加到<code>Set</code>中的元素必须定义<code>equal</code>方法，从而保证建立对象的唯一性。</p>
<p>实现<code>Set</code>接口的类有<code>HashSet</code>，<code>TreeSet</code>。</p>
<p>简单举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        HashSet&lt;String&gt; h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br>        h.add(<span class="hljs-string">&quot;one&quot;</span>);<br>        h.add(<span class="hljs-string">&quot;two&quot;</span>);<br>        h.add(<span class="hljs-string">&quot;three&quot;</span>);<br>        h.add(<span class="hljs-string">&quot;one&quot;</span>);<br>        Iterator&lt;String&gt; it = h.iterator;<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">print:</span><br><span class="hljs-comment">one</span><br><span class="hljs-comment">two</span><br><span class="hljs-comment">three</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure>
<h3 id="2、List接口实现类"><a href="#2、List接口实现类" class="headerlink" title="2、List接口实现类"></a>2、<code>List</code>接口实现类</h3><p><code>List</code>的明显特征就是<strong>它的元素都有一个确定的顺序</strong>。</p>
<p>实现它的类有<code>ArrayList</code>和<code>LinkedList</code></p>
<ul>
<li><strong><code>ArrayList</code></strong>：在内存中是顺序存储的。<code>ArrayList</code>实现了长度可变的数组，在内存中分配连续的空间。<strong>遍历元素和随即访问元素的效率较高</strong>。</li>
<li><strong><code>LinkedList</code></strong>：在内存中是以链表方式存储的。<strong>插入，删除元素的效率比较高</strong>。</li>
</ul>
<h3 id="3、Map接口实现类"><a href="#3、Map接口实现类" class="headerlink" title="3、Map接口实现类"></a>3、<code>Map</code>接口实现类</h3><p><code>Map</code>接口专门处理键值映射数据的存储，可以根据键实现对值的操作。</p>
<p>常用的实现类是<code>HashMap</code>和<code>TreeMap</code>。</p>
<h3 id="4、集合类的对比"><a href="#4、集合类的对比" class="headerlink" title="4、集合类的对比"></a>4、集合类的对比</h3><ul>
<li><code>Vector</code>和<code>ArrayList</code>的异同<ul>
<li>它们的实现原理相同，功能相同，很多情况下可以互用。</li>
<li>两者的主要区别是<ul>
<li><strong><code>Vector</code>线程安全，ArrayList重速度轻安全，线程非安全。</strong></li>
<li>长度增长时，<code>Vector</code>默认增长一倍，<code>ArrayList</code>默认增长50%。</li>
</ul>
</li>
</ul>
</li>
<li><code>Hashtable</code>和<code>HashMap</code>的异同<ul>
<li>它们的实现原理相同，功能相同，很多情况下可以互用。</li>
<li>两者的主要区别是<ul>
<li>Hashtable继承<code>Dictionary</code>类，HashMap实现Map接口。</li>
<li><strong><code>Hashtable</code>线程安全，<code>HashMap</code>线程不安全。</strong></li>
<li><strong><code>Hashtable</code>不允许<code>null</code>值，<code>HashMap</code>允许<code>null</code>值。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5、Iterator接口"><a href="#5、Iterator接口" class="headerlink" title="5、Iterator接口"></a>5、<code>Iterator</code>接口</h3><p>利用<code>Iterator</code>接口实现一个迭代器，来实现对集合的遍历，因为所有的集合接口和类都没有提供相应的遍历方法，而是由<code>Iterator</code>实现集合遍历。</p>
<p><code>Collection</code>接口的<code>iterate()</code>方法返回一个<code>Iterator</code>，然后通过<code>Iterate</code>接口的两个方法可以实现遍历</p>
<ul>
<li><code>boolean hasNext()</code>：判断是否存在另一个可访问的元素。</li>
<li><code>Object next()</code>：返回要访问的下一个元素。</li>
</ul>
<p><strong>Tips</strong>：<code>Iterator</code>仅用于遍历集合，<code>Iterator</code>本身并不提供承装对象的能力。如果需要创建<code>Iterator</code>对象，则必须有一个被迭代的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 迭代器遍历ArrayList示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 迭代器遍历Map示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            map.put(i, i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> map.entrySet().iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) it.next();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (Integer) entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (Integer) entry.getValue();<br>            System.out.println(key + <span class="hljs-string">&quot; : &quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="九、完善类的设计"><a href="#九、完善类的设计" class="headerlink" title="九、完善类的设计"></a>九、完善类的设计</h2><h3 id="（一）面向对象的几个基本原则"><a href="#（一）面向对象的几个基本原则" class="headerlink" title="（一）面向对象的几个基本原则"></a>（一）面向对象的几个基本原则</h3><h4 id="1、类的UML图"><a href="#1、类的UML图" class="headerlink" title="1、类的UML图"></a>1、类的UML图</h4><p><strong>UML（Unified Modeling Language）统一建模语言，又称标准建模语言，是用来对软件密集系统进行可视化建模的一种语言</strong></p>
<h4 id="2、面向接口的编程（面向抽象原则）"><a href="#2、面向接口的编程（面向抽象原则）" class="headerlink" title="2、面向接口的编程（面向抽象原则）"></a>2、面向接口的编程（面向抽象原则）</h4><h3 id="（二）设计模式"><a href="#（二）设计模式" class="headerlink" title="（二）设计模式"></a>（二）设计模式</h3><p><strong>设计模式是针对某一类问题的最佳解决方案</strong>。应当基于业务来选择设计模式。</p>
<blockquote>
<h5 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h5><ul>
<li><p><strong>创建型设计模式</strong></p>
<p>创建型设计模式设计对象的实例化，这类模式的特点是：不让用户代码依赖于对象的创建或排列方式，避免用户直接使用<code>new</code>运算符创建对象。</p>
<ul>
<li><p><strong>单例（Singleton）模式</strong></p>
<p>某个类<strong>只能生成一个实例</strong>，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p>
</li>
<li><p><strong>原型（Prototype）模式</strong></p>
<p>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p>
</li>
<li><p><strong>工厂方法（FactoryMethod）模式</strong></p>
<p>定义一个用于创建产品的接口，由子类决定生产什么产品。</p>
</li>
<li><p><strong>抽象工厂（AbstractFactory）模式</strong></p>
<p>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p>
</li>
<li><p><strong>建造者（Builder）模式</strong></p>
<p>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建他们，最后构建成该复杂对象。</p>
</li>
</ul>
</li>
<li><p><strong>结构型设计模式</strong></p>
<p>结构型设计模式涉及怎样合理的设计对象之间的交互通信，以及怎样合理为对象分配职责，让设计富有弹性，易维护，易复用。</p>
<ul>
<li><p><strong>代理（Proxy）模式</strong></p>
<p>为某对象提供一种代理以控制该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p>
</li>
<li><p><strong>适配器（Adapter）模式</strong></p>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
</li>
<li><p><strong>桥接（Bridge）模式</strong></p>
<p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</p>
</li>
<li><p><strong>装饰（Decorator）模式</strong></p>
<p>动态地给对象增加一些职责，即增加其额外的功能。</p>
</li>
<li><p><strong>外观（Facade）模式</strong></p>
<p>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p>
</li>
<li><p><strong>享元（Flyweight）模式</strong></p>
<p>运用共享技术来有效地支持大量细粒度对象的复用。</p>
</li>
<li><p><strong>组合（Composite）模式</strong></p>
<p>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p>
</li>
</ul>
</li>
<li><p><strong>行为型设计模式</strong></p>
<p>行为型设计模式涉及如何组合类和对象以形成更大的结构，和类有关的结构型模式涉及如何合理地使用继承机制，和对象有关的结构型模式涉及如何合理地使用对象组合机制。</p>
<ul>
<li><p><strong>模板方法（Template Method）模式</strong></p>
<p>定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类可以再不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
</li>
<li><p><strong>策略（Strategy）模式</strong></p>
<p>定义一系列算法，并将每个算法都封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p>
</li>
<li><p><strong>命令（Command）模式</strong></p>
<p>把一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。</p>
</li>
<li><p><strong>职责链（Chain of Responsibility）模式</strong></p>
<p>把请求从链中的一个对象传到下一个对象，知道请求被响应为止。通过这种方式去除对象之间的耦合。</p>
</li>
<li><p><strong>状态（State）模式</strong></p>
<p>允许一个对象在其内部状态发生改变时改变其行为能力。</p>
</li>
<li><p><strong>观察者（Observer）模式</strong></p>
<p>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p>
</li>
<li><p><strong>中介者（Mediator）模式</strong></p>
<p>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</p>
</li>
<li><p><strong>迭代器（Iterator）模式</strong></p>
<p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
</li>
<li><p><strong>访问者（Vistor）模式</strong></p>
<p>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式,，即每个元素有多个访问者对象访问。</p>
</li>
<li><p><strong>备忘录（Memento）模式</strong></p>
<p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p>
</li>
<li><p><strong>解释器（Interpreter）模式</strong></p>
<p>提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="1、策略模式"><a href="#1、策略模式" class="headerlink" title="1、策略模式"></a>1、策略模式</h4><p>当程序的主要类（相当于上下文角色）不希望暴露复杂的、与算法相关的数据结构，可以使用策略模式来封装算法，即将算法分别封装到具体策略中。</p>
<blockquote>
<h5 id="策略模式的结构"><a href="#策略模式的结构" class="headerlink" title="策略模式的结构"></a>策略模式的结构</h5><ul>
<li><p><strong>策略</strong></p>
<p>核心是将类中经常变化的部分分割出来，并将每种可能的变化对应的交给抽象类的一个子类或实现接口的一个类去负责。</p>
<p><strong>好处在于</strong>类的设计者不用关心具体实现，避免所设计的类过度依赖具体的实现。</p>
</li>
<li><p><strong>上下文（Context）</strong></p>
<p>上下文面向策略，即是面向接口<code>Strategy</code>的类。</p>
</li>
<li><p><strong>具体策略</strong></p>
<p>具体策略是实现<code>Strategy</code>接口的类，即必须重写接口中的方法。</p>
</li>
</ul>
<h5 id="举例：多个裁判给选手打分，用多种方法计算选手的得分情况。"><a href="#举例：多个裁判给选手打分，用多种方法计算选手的得分情况。" class="headerlink" title="举例：多个裁判给选手打分，用多种方法计算选手的得分情况。"></a>举例：多个裁判给选手打分，用多种方法计算选手的得分情况。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 策略接口命名为Strategy</span><br><span class="hljs-comment">// Strategy.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br>	<span class="hljs-type">double</span> <span class="hljs-title function_">calcScore</span><span class="hljs-params">(<span class="hljs-type">double</span>[] scores)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文</span><br><span class="hljs-comment">// AverageScore.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AverageScore</span> &#123;<br><span class="hljs-keyword">private</span> Strategy s;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(Strategy s)</span> &#123; <span class="hljs-built_in">this</span>.s = s; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">(<span class="hljs-type">double</span>[] scores)</span> &#123;<br>  	<span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s.calcScore(scores);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体策略 策略A</span><br><span class="hljs-comment">// StrategyA.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcScore</span><span class="hljs-params">(<span class="hljs-type">double</span>[] scores)</span> &#123;<br>  		<span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  		<span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> score : scores) sum += score;<br>  		<span class="hljs-keyword">return</span> sum / scores.length;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体策略 策略B</span><br><span class="hljs-comment">// StrategyB.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcScore</span><span class="hljs-params">(<span class="hljs-type">double</span>[] scores)</span> &#123;<br>  	<span class="hljs-keyword">if</span> (scores.length &lt;= <span class="hljs-number">2</span>) &#123;<br>      	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyA</span>().calcScore(scores);<br>  	&#125;<br>  	<span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  	Arrays.sort(scores); <span class="hljs-comment">// 去掉一个最高分，去掉一个最低分</span><br>  	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; scores.length - <span class="hljs-number">1</span>; i++) &#123;<br>      	sum += scores[i];<br>  	&#125;<br>  	<span class="hljs-keyword">return</span> sum / (scores.length - <span class="hljs-number">2</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  		<span class="hljs-type">double</span>[] scores = &#123;<span class="hljs-number">90</span>, <span class="hljs-number">92</span>, <span class="hljs-number">94</span>, <span class="hljs-number">96</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>&#125;;<br>  		<span class="hljs-type">AverageScore</span> <span class="hljs-variable">as</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AverageScore</span>();<br>  		as.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyA</span>());<br>  		System.out.println(as.getScore(scores));<br>  		as.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyB</span>());<br>  		System.out.println(as.getScore(scores));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>策略模式的优点</strong></p>
<ul>
<li>上下文和具体策略是松耦合关系。</li>
<li>策略模式满足”开-闭原则“。</li>
</ul>
<h4 id="2、访问者模式"><a href="#2、访问者模式" class="headerlink" title="2、访问者模式"></a>2、访问者模式</h4><p>当需要对集合中的对象进行很多不同且不相关的操作，同时我们又不希望修改对象的类，此时就可以使用访问者模式。访问者模式可以在<code>Visitor</code>类中集中定义一些关于集合中对象的操作。</p>
<blockquote>
<h5 id="访问者模式模式结构包含的四个角色"><a href="#访问者模式模式结构包含的四个角色" class="headerlink" title="访问者模式模式结构包含的四个角色"></a>访问者模式模式结构包含的四个角色</h5><ul>
<li><p><strong>抽象元素（Element）</strong></p>
<p>被访问的元素，一个抽象类，该类定义了接受访问者的accept操作。访问者需要访问元素，<strong>元素必须提供允许访问这访问它的方法。</strong></p>
</li>
<li><p><strong>具体元素（Concrete Element）</strong></p>
<p>被访问的元素，Element的子类。</p>
</li>
<li><p><strong>抽象访问者（Visitor）：规定访问时的操作</strong></p>
<p>一个接口，该接口定义操作具体元素的方法。在某些设计中，可能需要定义作用域类中的数据的新操作，而且这些新操作不应当由该类中的某个实例方法来承担时，将该方法定义于抽象访问者中。</p>
</li>
<li><p><strong>具体访问者（Concrete Visitor）：规定访问时的操作</strong></p>
<p>实现Vistor接口的类。</p>
</li>
</ul>
<h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>根据电表显示的用电量计算用户的电费。用户包括居民和企业，访问同一个电表，及分别按家用电标准和工业用电标准计算了电费（家用：6000 度以下 0.6 元/度，以上 1.05 元/度；企业：15000 度以下 1.52 元/度；以上 2.78 元/度）。</p>
<p><strong>PS：</strong>电表有自己显示用电量的方法，但需要定义一个方法来计算电费，即需要定义一个作用于电量的新操作，但显然这个新的操作不应当由电表来承担。应当由记表员来观察电表的用电量，然后按照有关收费标准计算出电费，即让一个称作访问者的对象来访问电表。</p>
<ul>
<li>抽象访问者</li>
<li>具体访问者：居民和企业用户</li>
<li>抽象元素：抽象类：<code>Element</code></li>
<li>具体元素：模拟电表：<code>Ammeter</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象访问者</span><br><span class="hljs-comment">// Vistor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">HOME_STANDARD_ACCOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6000</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">HOME_LEVEL_LOW</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.6</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">HOME_LEVEL_HIGH</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.05</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">INDUSTRY_STANDARD_ACCOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">15000</span>;<br>    <span class="hljs-type">double</span>  <span class="hljs-variable">INDUSTRY_LEVEL_LOW</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.52</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">INDUSTRY_LEVEL_HIGH</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.78</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Element e)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体访问者1：居民</span><br><span class="hljs-comment">// HomeVisitor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Element e)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">fee</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> e.displayAmount();<br>        <span class="hljs-keyword">if</span> (amount &lt;= HOME_STANDARD_ACCOUNT)<br>            fee = amount * HOME_LEVEL_LOW;<br>        <span class="hljs-keyword">else</span><br>            fee = HOME_STANDARD_ACCOUNT * HOME_LEVEL_LOW + (amount - HOME_STANDARD_ACCOUNT) * HOME_LEVEL_HIGH;<br>        <span class="hljs-keyword">return</span> fee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体访问者2：企业用户</span><br><span class="hljs-comment">// IndustryVisitor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndustryVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Element e)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">fee</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> e.displayAmount();<br>        <span class="hljs-keyword">if</span> (amount &lt;= INDUSTRY_STANDARD_ACCOUNT)<br>            fee = amount * INDUSTRY_LEVEL_LOW;<br>        <span class="hljs-keyword">else</span><br>            fee = INDUSTRY_STANDARD_ACCOUNT * INDUSTRY_LEVEL_LOW + (amount - INDUSTRY_STANDARD_ACCOUNT) * INDUSTRY_LEVEL_HIGH;<br>        <span class="hljs-keyword">return</span> fee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象元素</span><br><span class="hljs-comment">// Element.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor v)</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">displayAmount</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAmount</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体元素</span><br><span class="hljs-comment">// Ammeter.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ammeter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amount;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor v)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">fee</span> <span class="hljs-operator">=</span> v.visit(<span class="hljs-built_in">this</span>);<br>        System.out.printf(<span class="hljs-string">&quot;The fee is %.2f\n&quot;</span>, fee);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAmount</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">displayAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Ammeter</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ammeter</span>();<br>        a.setAmount(<span class="hljs-number">8000</span>);<br>        <span class="hljs-type">Visitor</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HomeVisitor</span>();<br>        a.accept(v);<br>        v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndustryVisitor</span>();<br>        a.accept(v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="3、工厂模式"><a href="#3、工厂模式" class="headerlink" title="3、工厂模式"></a>3、工厂模式</h4><p><strong>工厂模式</strong>是定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中，具有<strong>创建型模式</strong>中要求的”<strong>创建与使用分离</strong>“的特点。</p>
<ul>
<li><p><strong>简单工厂</strong>：为产品创建工厂类，客户调用工厂的方法来获得产品。</p>
<blockquote>
<p>例：模拟生产中性笔，传入参数Red或red生产红笔，传入参数Black或black生产黑笔。其他颜色中性笔暂不生产。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Pen.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pen</span> &#123;<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenFactory.java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedPen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pen</span> &#123;<br>	RedPen() &#123;create();&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>  		System.out.println(<span class="hljs-string">&quot;Create a RedPen.&quot;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackPen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pen</span> &#123;<br>	BlackPen() &#123;create();&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>  		System.out.println(<span class="hljs-string">&quot;Create a BlackPen.&quot;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenFactory</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pen <span class="hljs-title function_">create</span><span class="hljs-params">(String color)</span> &#123;<br>  		<span class="hljs-keyword">if</span> (color.equalsIgnoreCase(<span class="hljs-string">&quot;Red&quot;</span>))<br>      		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedPen</span>();<br>  		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color.equalsIgnoreCase(<span class="hljs-string">&quot;Black&quot;</span>))<br>      		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackPen</span>();<br>  		<span class="hljs-keyword">else</span> &#123;<br>      		System.out.println(<span class="hljs-string">&quot;Can&#x27;t create &quot;</span> + color + <span class="hljs-string">&quot; pen.&quot;</span>);<br>      		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenTest.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenTest</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  		<span class="hljs-type">Pen</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> PenFactory.create(<span class="hljs-string">&quot;Red&quot;</span>);<br>  		<span class="hljs-type">Pen</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> PenFactory.create(<span class="hljs-string">&quot;Black&quot;</span>);<br>  		<span class="hljs-type">Pen</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> PenFactory.create(<span class="hljs-string">&quot;Blue&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>工厂方法</strong></p>
<blockquote>
<p>此模式具有四种角色</p>
<ul>
<li>抽象产品</li>
<li>具体产品</li>
<li>抽象生产者</li>
<li>具体生产者</li>
</ul>
<p>例：模拟生产中性笔，红色和黑色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenCore.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenCore</span> &#123;<br>	<span class="hljs-keyword">protected</span> String color;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeDown</span><span class="hljs-params">(String s)</span> &#123;<br>  		System.out.println(<span class="hljs-string">&quot;Write the word :\&quot;&quot;</span> + s + <span class="hljs-string">&quot;\&quot; in &quot;</span> + color + <span class="hljs-string">&quot; color.&quot;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackPenCore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PenCore</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">BlackPenCore</span><span class="hljs-params">()</span> &#123;<br>  		color = <span class="hljs-string">&quot;Black&quot;</span>;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedPenCore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PenCore</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">RedPenCore</span><span class="hljs-params">()</span> &#123;<br>  		color = <span class="hljs-string">&quot;Red&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenFactory.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenFactory</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> PenCore <span class="hljs-title function_">getPenCore</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackPenCoreCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PenFactory</span> &#123;<br>	<span class="hljs-keyword">public</span> PenCore <span class="hljs-title function_">getPenCore</span><span class="hljs-params">()</span> &#123;<br>  		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackPenCore</span>();<br>	&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedPenCoreCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PenFactory</span> &#123;<br>	<span class="hljs-keyword">public</span> PenCore <span class="hljs-title function_">getPenCore</span><span class="hljs-params">()</span> &#123;<br>  		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedPenCore</span>();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenCoreTest.java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BallPen</span> &#123;<br>	PenCore pc;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPenCore</span><span class="hljs-params">(PenCore pc)</span> &#123;<br>  		<span class="hljs-built_in">this</span>.pc = pc;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String s)</span> &#123;<br>  		pc.writeDown(s);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenCoreTest</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  		PenFactory pf;<br>  		<span class="hljs-type">BallPen</span> <span class="hljs-variable">bp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BallPen</span>();<br>  		pf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackPenCoreCreator</span>();<br>  		bp.setPenCore(pf.getPenCore());<br>  		bp.write(<span class="hljs-string">&quot;Java&quot;</span>);<br>  		pf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedPenCoreCreator</span>();<br>  		bp.setPenCore(pf.getPenCore());<br>  		bp.write(<span class="hljs-string">&quot;Linux&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="十、异常处理s"><a href="#十、异常处理s" class="headerlink" title="十、异常处理s"></a>十、异常处理s</h2><p>在编程时，通常会遇到三类错误：</p>
<ul>
<li><strong>编译错误（CE）</strong></li>
<li><strong>逻辑错误</strong></li>
<li><strong>运行时错误（RE）：在程序运行的过程中，如果发生了不可能执行的操作，就会出现运行时错误。</strong></li>
</ul>
<p><strong>异常</strong>是一个可以正确运行的程序，在运行的过程中可能发生的错误。编译系统检查出来的语法错误、导致程序运行结果不正确的逻辑错误，都不属于异常的范围。</p>
<p>异常实际是程序中错误导致中断了正常的指令流的一种事件。</p>
<h3 id="1、异常类的结构"><a href="#1、异常类的结构" class="headerlink" title="1、异常类的结构"></a>1、异常类的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java/%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="异常类型"></p>
<ul>
<li><code>Throwable</code>是所有异常类的父类，他是</li>
<li><strong><code>Object</code>的直接子类。</strong>是类库<code>java.lang</code>包的一个类。</li>
<li><strong><code>Exception</code>类继承自Throwable类。</strong>所有的<code>Throwable</code>类的子孙类所产生的对象都是例外。</li>
<li><code>Error</code>：由Java虚拟机生成并抛出，Java程序不做处理。</li>
<li><code>Runtime Exception</code>：由系统检测，用户的Java程序可以不做处理，系统将其交给缺省的异常处理程序。</li>
<li><strong><code>非Runtime Exception</code>：Java编译器要求Java程序必须捕捉或声明所有的非运行时异常。</strong></li>
<li><code>throw</code>：用户自己产生异常。</li>
</ul>
<h3 id="2、异常分类"><a href="#2、异常分类" class="headerlink" title="2、异常分类"></a>2、异常分类</h3><h4 id="按编译时是否受检来分"><a href="#按编译时是否受检来分" class="headerlink" title="按编译时是否受检来分"></a>按编译时是否受检来分</h4><ul>
<li><p><strong>非受检异常</strong>：包括<code>Runtime Exception</code>及其子类，<code>Error</code>及其子类。编译器对非受检异常类不进行检查。</p>
<blockquote>
<p><strong>非受检异常只能在程序执行时被检测到，而不能在编译时被检测到。</strong></p>
</blockquote>
</li>
<li><p><strong>受检异常</strong>：除了非受检异常意外其他的异常（即其他的异常类则是可检测的类）。</p>
<blockquote>
<ul>
<li>这些异常在编译时就能被Java编译器所检测到。</li>
<li><strong>必须采用声明异常或者<code>try-catch</code>方式处理异常。</strong></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="3、Java异常处理机制"><a href="#3、Java异常处理机制" class="headerlink" title="3、Java异常处理机制"></a>3、Java异常处理机制</h3><blockquote>
<h5 id="Java异常处理：抓抛模型"><a href="#Java异常处理：抓抛模型" class="headerlink" title="Java异常处理：抓抛模型"></a>Java异常处理：抓抛模型</h5><p>如果一个方法内抛出异常，该异常会被抛到调用方法中，如果一场没有在调用方法中处理，它继续被抛给这个调用方法的调用者。这个过程将一直继续下去，直到一场被处理，这一过程被称为：捕获异常（catch）。</p>
<p>如果一个异常回到<code>main()</code>方法，并且<code>main()</code>也不处理，则程序运行终止。</p>
</blockquote>
<h3 id="4、try-catch-finally处理异常"><a href="#4、try-catch-finally处理异常" class="headerlink" title="4、try...catch...finally处理异常"></a>4、<code>try...catch...finally</code>处理异常</h3><p><strong>捕获异常并处理异常</strong></p>
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">// 接受监视的程序块，在此区域内发生的异常，由catch中指定的程序处理</span><br>    &#125; <span class="hljs-keyword">catch</span> (ExceptionType e) &#123;<br>        <span class="hljs-comment">// 抛出ExceptionType异常时要执行的代码</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 无条件执行的语句</span><br>        <span class="hljs-comment">// 一般用于释放资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>同一段程序可能产生不止一种异常，用多个<code>catch</code>子句来检查每一种异常类型，第一个与异常匹配的<code>catch</code>将会被执行。</li>
<li>如果<strong>一个异常类和这个异常类的子类都出现在<code>catch</code>中</strong>，应该<strong>把子类放在前面</strong>，否则将永远不会到达子类。</li>
<li><code>finally</code>：<strong>无条件执行语句，一般用于释放资源。</strong>即使没有<code>catch</code>语句，<code>finally</code>语句块也会在执行了<code>try</code>语句块之后立即执行。（比如在<code>try</code>中进行文件操作，使用了文件流，因此需要在<code>finally</code>中关闭文件流）</li>
</ul>
<h3 id="5、Throws语句声明异常"><a href="#5、Throws语句声明异常" class="headerlink" title="5、Throws语句声明异常"></a>5、<code>Throws</code>语句声明异常</h3><p><strong>声明异常：</strong>一个方法不处理它产生的异常，而是沿着调用层次向上传递，由调用它的方法来处理这些异常，叫声明异常。</p>
<p><code>Throws</code>语句用来表明一个方法可能抛出的各种异常，并说明该方法会抛出但不会捕获异常。</p>
<p>声明异常的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[访问权限修饰符][返回值类型][方法名](参数列表) <span class="hljs-keyword">throws</span> 异常列表 &#123;&#125;<br></code></pre></td></tr></table></figure>
<p><strong>一定是由调用方法处理该异常，如果最终方法也没有处理异常，异常将交给系统处理。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExceptionType &#123;<br>        <span class="hljs-comment">// do something</span><br>        <span class="hljs-comment">// 抛出了ExceptionType类型的异常</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f();<br>        &#125; <span class="hljs-keyword">catch</span> (ExceptionType e) &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<p><strong>重写方法不能抛出比被重写方法范围更大的异常类型。</strong></p>
<h3 id="6、人工抛出异常：创建用户自定义的异常"><a href="#6、人工抛出异常：创建用户自定义的异常" class="headerlink" title="6、人工抛出异常：创建用户自定义的异常"></a>6、人工抛出异常：创建用户自定义的异常</h3><p>Java自定义异常不是由Java系统检测到的异常，而是由用户自己定义的异常。用户定义的异常，必须由用户自己抛出<code>throw new MyException</code>。</p>
<p>自定义异常语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class [自定义异常名] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-comment">// body</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>throw</code>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> [异常对象]<br></code></pre></td></tr></table></figure>
<p><strong>注意事项：程序会在<code>throw</code>语句处立即终止，转向<code>try...catch</code>寻找异常处理方法。</strong></p>
<blockquote>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MyException.java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>	MyException(<span class="hljs-type">int</span> a) &#123;<br>  		<span class="hljs-built_in">this</span>.x = a;<br>	&#125;<br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>  		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyException&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> MyException &#123;<br>  		System.out.println(<span class="hljs-string">&quot;\t此处引用method (&quot;</span> + a + <span class="hljs-string">&quot;)&quot;</span>);<br>  		<span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>) <br>      	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(a);<br> 		 System.out.println(<span class="hljs-string">&quot;正常返回&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  		<span class="hljs-keyword">try</span> &#123;<br>      	System.out.println(<span class="hljs-string">&quot;进入异常监视区&quot;</span>);<br>      	method(<span class="hljs-number">8</span>);<br>      	method(<span class="hljs-number">15</span>);<br>      	method(<span class="hljs-number">7</span>);<br>  		&#125; <span class="hljs-keyword">catch</span>(MyException e) &#123;<br>      	System.out.println(<span class="hljs-string">&quot;\t&quot;</span> + e.toString());<br>  		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="7、try-catch、throws、throw的区别"><a href="#7、try-catch、throws、throw的区别" class="headerlink" title="7、try...catch、throws、throw的区别"></a>7、<code>try...catch</code>、<code>throws</code>、<code>throw</code>的区别</h3><ul>
<li><p><strong><code>try...catch</code></strong>使用在<strong>方法中</strong>，用来<strong>捕获异常</strong>。</p>
<p><strong><code>throws</code></strong>用在<strong>方法的声明处</strong>，用来<strong>声明抛出异常</strong>。</p>
</li>
<li><p><strong><code>throws</code></strong>语句在<strong>方法声明处</strong>声明<strong>抛出特定的异常</strong>。</p>
<p><strong><code>throw</code></strong>语句在<strong>方法中</strong>抛出<strong>具体的异常</strong>。</p>
</li>
</ul>
<h2 id="十一、Java-IO"><a href="#十一、Java-IO" class="headerlink" title="十一、Java IO"></a>十一、Java IO</h2><h3 id="（一）基本输入输出"><a href="#（一）基本输入输出" class="headerlink" title="（一）基本输入输出"></a>（一）基本输入输出</h3><h4 id="1、命令行输入"><a href="#1、命令行输入" class="headerlink" title="1、命令行输入"></a>1、命令行输入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandLineArgu</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;args[&quot;</span> + i +<span class="hljs-string">&quot;] is \&quot;&quot;</span> + args[i] + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&gt;&gt;&gt; javac CommandLineArgu.java<br>&gt;&gt;&gt; java CommandLineArgu arg0 arg1 arg2<br><span class="hljs-built_in">args</span>[<span class="hljs-number">0</span>] <span class="hljs-built_in">is</span> <span class="hljs-string">&quot;arg0&quot;</span><br><span class="hljs-built_in">args</span>[<span class="hljs-number">1</span>] <span class="hljs-built_in">is</span> <span class="hljs-string">&quot;arg1&quot;</span><br><span class="hljs-built_in">args</span>[<span class="hljs-number">2</span>] <span class="hljs-built_in">is</span> <span class="hljs-string">&quot;arg2&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>注：<code>args[0]</code>是从不包括程序名称的第一个参数开始。</strong></p>
<h4 id="2、标准输入输出"><a href="#2、标准输入输出" class="headerlink" title="2、标准输入输出"></a>2、标准输入输出</h4><ul>
<li><p><strong>标准输入输出中有三个基本的<code>I/O</code>对象</strong></p>
<blockquote>
<ul>
<li>标准输入：<code>System.in</code></li>
<li>标准输出：<code>System.out</code></li>
<li>标准错误：<code>System.err</code></li>
</ul>
</blockquote>
</li>
<li><p><strong><code>java.util.Scanner</code></strong></p>
<p><code>Scanner</code>通过<strong>分隔符模式</strong>将输入分解为标记，默认情况下<strong>该分隔符模式与空白匹配。</strong></p>
<ul>
<li><p>定义输入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure>
</li>
<li><p>输入写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入一个word</span><br>in.next();<br><span class="hljs-comment">// 输入接下来一行</span><br>in.nextLine();<br><span class="hljs-comment">// 输入一个int类型的数</span><br>in.nextInt();<br><span class="hljs-comment">// 可以通过使用不同的next方法将得到的标记转换为不同类型的值</span><br></code></pre></td></tr></table></figure>
<blockquote>
<h5 id="关于next-和nextLine-的细节"><a href="#关于next-和nextLine-的细节" class="headerlink" title="关于next()和nextLine()的细节"></a>关于<code>next()</code>和<code>nextLine()</code>的细节</h5><p>通过<code>Scanner</code>类的<code>next()</code>与<code>nextLine()</code>方法获取输入的字符串，在读取前我们一般需要使用hasNext()与<code>hasNextLine</code>判断是否还有输入的数据。</p>
<ul>
<li><p><code>next()</code></p>
<p>只读取输入直到空格。它不能读两个由空格或符号隔开的单词。此外，<code>next()</code>在读取输入后，光标放在同一行。<strong>即<code>next()</code>只读取空格之前的数据，并且将光标指向本行。</strong></p>
</li>
<li><p><code>nextLine()</code></p>
<p>读取输入，包括单词之间的空格和除了回车以外的所有符号<strong>（即读完一整行，读到行尾）</strong>。读取输入后，<code>nextLine()</code>将光标定位在下一行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title function_">readWord</span><span class="hljs-params">()</span> &#123;<br>        ArrayList&lt;String&gt; words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">while</span> (!in.hasNext(<span class="hljs-string">&quot;0&quot;</span>)) &#123; <span class="hljs-comment">// 这里设置一个循环终止标志的目的是为了避免死循环，下同</span><br>            words.add(in.next());<br>        &#125;<br>        <span class="hljs-keyword">return</span> words;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title function_">readLine</span><span class="hljs-params">()</span> &#123;<br>        ArrayList&lt;String&gt; lines = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">while</span> (!in.hasNext(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            lines.add(in.nextLine());<br>        &#125;<br>        <span class="hljs-keyword">return</span> lines;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readAndShow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 需要注意的是：要按照顺序输入int, double, string类型的数据。</span><br>        <span class="hljs-comment">/* eg：</span><br><span class="hljs-comment">        输入：1 1.5 Java </span><br><span class="hljs-comment">        输出：i = 1, d = 1.5, s = Java</span><br><span class="hljs-comment">        若不按顺序</span><br><span class="hljs-comment">        输入：1.5 1 Java</span><br><span class="hljs-comment">        输出：i = 0, d = 1.5, s = 1</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (in.hasNextInt()) &#123;<br>            i = in.nextInt(); <span class="hljs-comment">// 读一个整数</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (in.hasNextDouble()) &#123;<br>            d = in.nextDouble(); <span class="hljs-comment">// 读一个浮点数</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (in.hasNext()) &#123;<br>            s = in.next(); <span class="hljs-comment">// 读一个单词</span><br>        &#125;<br>        System.out.println(String.format(<span class="hljs-string">&quot;i = %d, d = %.2f, s = %s&quot;</span>, i, d, s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="（二）文件与数据流"><a href="#（二）文件与数据流" class="headerlink" title="（二）文件与数据流"></a>（二）文件与数据流</h3><h4 id="1、Java文件管理（File类）"><a href="#1、Java文件管理（File类）" class="headerlink" title="1、Java文件管理（File类）"></a>1、Java文件管理（<code>File</code>类）</h4><h5 id="1）概念"><a href="#1）概念" class="headerlink" title="1）概念"></a>1）概念</h5><ul>
<li><code>File</code>类代表<strong>与平台无关</strong>的文件和目录。</li>
<li><code>File</code>类能新建、删除、重命名文件和目录。</li>
<li><code>File</code>类一般不涉及文件内部的具体内容，而是从整体上对文件进行处理，因此<code>File</code>类不能访问文件内容本身。<strong>如果需要访问文件内容本身，则需要使用文件输入/输出流（<code>FileInputStream/FileOutputStream</code>)</strong></li>
<li>在Java文件体系中，文件和目录是统一抽象成文件来处理的。</li>
<li><strong>如果一个<code>File</code>是目录的话，可以使用<code>list()</code>方法</strong>取得文件名列表以及子目录结构等。</li>
</ul>
<h5 id="2）主要方法"><a href="#2）主要方法" class="headerlink" title="2）主要方法"></a>2）主要方法</h5><ul>
<li><p><strong>构造方法</strong></p>
<p><code>File</code>类有四个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">File(File parent, String child);<br>File(String pathName);<br>File(String parent, String child);<br>File(URI uri);<br></code></pre></td></tr></table></figure>
<p><strong>注意：这里的对象指的可以是一个我们通常所说的文件，也可以是一个目录（路径）；可以是个具体存在的文件，也可以是个尚未存在的文件。</strong></p>
</li>
<li><p><strong>常用方法</strong></p>
<ul>
<li><p><strong>访问文件名</strong></p>
<p>| String getName()                | 取得文件名                           |<br>| ———————————————- | —————————————————— |<br>| <strong>String getPath</strong>              | <strong>取得文件路径</strong>                     |<br>| <strong>File getParentFile()</strong>        | <strong>取得父目录对象，不存在时返回null</strong> |<br>| <strong>String getAbsolutePath()</strong>    | <strong>取得绝对路径</strong>                     |<br>| <strong>String getParent()</strong>          | <strong>取得父目录名，不存在时返回null</strong>   |<br>| <strong>boolean renameTo(File dest)</strong> | <strong>重命名文件</strong>                       |</p>
</li>
<li><p><strong>文件检测</strong></p>
<p>| boolean exists()         | 测试文件是否存在，存在即返回true |<br>| ———————————— | ———————————————— |<br>| <strong>boolean canWrite()</strong>   | <strong>文件存在并可写，返回true</strong>     |<br>| <strong>boolean canRead()</strong>    | <strong>文件存在并可读，返回true</strong>     |<br>| <strong>boolean isFile()</strong>     | <strong>如果是文件，返回true</strong>         |<br>| <strong>boolean isDiretory()</strong> | <strong>如果是目录，返回true</strong>         |</p>
</li>
<li><p><strong>获取常规文件信息</strong></p>
<p>| long lastModified() | 返回文件的最后修改时间 |<br>| —————————- | ——————————— |<br>| <strong>long length()</strong>   | <strong>返回文件的长度</strong>     |</p>
</li>
<li><p><strong>文件操作相关</strong></p>
<p>| boolean createNewFile() | 如果文件不存在，就创建它 |<br>| ———————————- | ———————————— |<br>| <strong>boolean delete()</strong>    | <strong>删除一个文件或目录</strong>   |</p>
</li>
<li><p><strong>目录操作相关</strong></p>
<p>| boolean mkdir()                          | 创建一个目录                                   |<br>| ———————————————————— | ——————————————————————— |<br>| <strong>boolean mkdirs()</strong>                     | <strong>创建一个目录，包括所有必须但不存在的父目录</strong> |<br>| <strong>String[] list()</strong>                      | <strong>列出这个目录下的文件和子目录</strong>               |<br>| <strong>String[] list(FilenameFilter filter)</strong> | <strong>有文件过滤器的list</strong>                         |<br>| <strong>File[] listFiles()</strong>                   | <strong>列出这个目录下的文件和子目录的File对象</strong>     |<br>| <strong>File[] listFiles(FileFilter filter)</strong>  | <strong>有文件过滤器的listFiles</strong>                    |</p>
</li>
</ul>
</li>
</ul>
<h4 id="2、输入输出流"><a href="#2、输入输出流" class="headerlink" title="2、输入输出流"></a>2、输入输出流</h4><h5 id="1）概念-1"><a href="#1）概念-1" class="headerlink" title="1）概念"></a>1）概念</h5><p>数据流：数据流是指一组有顺序的、有起点和终点的字节集合。</p>
<p>Java程序不能直接操作I/O设备，而是在程序和设备之间加入了一个中间介质，这就是<strong>流(Stream)</strong>。建立流实际上就是<strong>建立数据传输通道</strong>，将起点和终点连接起来。</p>
<ul>
<li>输入流：将数据从文件、标准输入或其他外部设备输入加载到内存。</li>
<li>输出流：将内存中的数据保存到文件中、或传输给输出设备。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">		- InputStream<br>		- OutputStream<br>		- Reader<br>Object	- Writer<br>		- File<br>		- RandomAccessFile<br></code></pre></td></tr></table></figure>
<h5 id="2）分类"><a href="#2）分类" class="headerlink" title="2）分类"></a>2）分类</h5><blockquote>
<ul>
<li>输入数据流：只能读，不能写<ul>
<li>字节流：InputStream的子类</li>
<li>字符流：Reader的子类</li>
</ul>
</li>
<li>输出数据流：只能写，不能读<ul>
<li>字节流：OutputStream的子类</li>
<li>字符流：Writer的子类</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="3）I-O流"><a href="#3）I-O流" class="headerlink" title="3）I/O流"></a>3）I/O流</h5><blockquote>
<p><strong><code>InputStream</code></strong></p>
<ul>
<li><p><code>FileInputStream</code>用于从本地文件中读取数据。</p>
</li>
<li><p><code>PipedInputStream</code>用于管道输入/输出时从管道中读取数据。</p>
</li>
<li><p><code>FilterInputStream</code>子类</p>
<ul>
<li><code>DataInputStream</code>是读取Java中的基本数据类型。</li>
<li><code>PushbackStream</code>读取数据时对数据进行缓冲，提高效率，增加特殊功能。</li>
<li><code>BufferedInputStream</code>读取数据时对数据进行缓冲，提高效率，增加特殊功能。</li>
</ul>
</li>
<li><p><code>ByteArrayInputStream</code>包含一个内存缓冲区，用于从内存中读取数据。</p>
</li>
<li><p><code>SequencedInputStream</code>把两个或者更多的<code>InputStream</code>输入流对象转换为单个的<code>InputStream</code>输入流对象使用。</p>
</li>
<li><p><code>ObjectInputStream</code>用来读取对象。</p>
</li>
<li><p><code>AudioInputStream</code>用于<code>Audio</code>的输入输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常用方法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span>;<br><span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>OutputStream</code></strong></p>
<ul>
<li><p><code>FileOutputStream</code>用于向本地文件中写入数据。</p>
</li>
<li><p><code>PipedOutputStream</code>用于管道输入/输出时把数据向管道输出。</p>
</li>
<li><p><code>FilterOutputStream</code>子类</p>
<ul>
<li><code>DataOutputStream</code>提供对基本数据类型的支持。</li>
<li><code>BufferedOutputStream</code></li>
<li><code>PrintStream</code>提供了向屏幕输出有格式数据的方法。</li>
</ul>
</li>
<li><p><code>ObjectOutputStream</code>用来输出对象。</p>
</li>
<li><p><code>ByteArrayOutputStream</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常用方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>Reader</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">			- BufferedReader &lt;- LineNumberReader<br>        	- CharArrayReader<br>        	- StringReader<br>Reader &lt;-<br>            - InputStreamReader &lt;- FileReader<br>            - PipedReader<br>            - FilterReader &lt;- PushbackReader<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//常用函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cbuf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cbuf, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br>String <span class="hljs-title function_">readLine</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">ready</span><span class="hljs-params">()</span>;<br><span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readAheadLimit)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p><strong><code>Writer</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">			- BufferedWriter<br>            - CharArrayWriter<br>            - StringWriter<br>Writer &lt;- 	- OutputStreamWriter &lt;- FileWriter<br>            - PrintWriter<br>            - PipedWriter<br>            - FilterWriter<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常用函数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cbuf)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cbuf,l <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String string)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String string, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BUAA/" class="category-chain-item">BUAA</a>
  
  
    <span>></span>
    
  <a href="/categories/BUAA/OO/" class="category-chain-item">OO</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/BUAA/">#BUAA</a>
      
        <a href="/tags/OO/">#OO</a>
      
        <a href="/tags/Java/">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面向对象程序设计-Java</div>
      <div>http://authormq.github.io/2023/01/29/面向对象程序设计-Java/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>mq</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月29日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年1月29日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/29/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E4%B8%8EIO%E6%A6%82%E8%BF%B0/" title="计组-总线与IO概述">
                        <span class="hidden-mobile">计组-总线与IO概述</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
