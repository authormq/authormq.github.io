<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BUAA-Software-算法模板</title>
    <link href="/2023/02/04/BUAA-Software-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/02/04/BUAA-Software-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>BUAA Software 大二上 算法模板汇总</p><span id="more"></span><h1 id="算法Template"><a href="#算法Template" class="headerlink" title="算法Template"></a>算法Template</h1><h2 id="1、DP"><a href="#1、DP" class="headerlink" title="1、DP"></a>1、DP</h2><h3 id="1-1、01背包"><a href="#1-1、01背包" class="headerlink" title="1.1、01背包"></a>1.1、01背包</h3><blockquote><p>有N种物品和一个容量为V的背包，<strong>每种物品都只有一件</strong>。第i种物品的体积是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p></blockquote><h4 id="（1）普通解法"><a href="#（1）普通解法" class="headerlink" title="（1）普通解法"></a>（1）普通解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 105</span><br><span class="hljs-type">int</span> dp[MAXSIZE][MAXSIZE];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DP_01Bag</span><span class="hljs-params">(<span class="hljs-type">int</span> dp[][MAXSIZE], <span class="hljs-type">int</span> v[], <span class="hljs-type">int</span> w[], <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> V)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++) &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);<br>    <span class="hljs-type">int</span> v[MAXSIZE], w[MAXSIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">DP_01Bag</span>(dp, v, w, N, V);<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）滚动数组"><a href="#（2）滚动数组" class="headerlink" title="（2）滚动数组"></a>（2）滚动数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 空间优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 105</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>][MAXSIZE];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DP_01Bag</span><span class="hljs-params">(<span class="hljs-type">int</span> dp[][MAXSIZE], <span class="hljs-type">int</span> v[], <span class="hljs-type">int</span> w[], <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> V)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++) &#123;<br>            dp[i % <span class="hljs-number">2</span>][j] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) &#123;<br>                dp[i % <span class="hljs-number">2</span>][j] = <span class="hljs-built_in">max</span>(dp[i % <span class="hljs-number">2</span>][j], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j - v[i]] + w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[N % <span class="hljs-number">2</span>][V];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);<br>    <span class="hljs-type">int</span> v[MAXSIZE], w[MAXSIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">DP_01Bag</span>(dp, v, w, N, V);<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）二进制优化（一维数组）"><a href="#（3）二进制优化（一维数组）" class="headerlink" title="（3）二进制优化（一维数组）"></a>（3）二进制优化（一维数组）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 空间优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 105</span><br><span class="hljs-type">int</span> dp[MAXSIZE];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DP_01Bag</span><span class="hljs-params">(<span class="hljs-type">int</span> dp[], <span class="hljs-type">int</span> v[], <span class="hljs-type">int</span> w[], <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j--) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j - v[i]] + w[i], dp[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);<br>    <span class="hljs-type">int</span> v[MAXSIZE], w[MAXSIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">DP_01Bag</span>(dp, v, w, N, V);<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2、完全背包"><a href="#1-2、完全背包" class="headerlink" title="1.2、完全背包"></a>1.2、完全背包</h3><blockquote><p>有N种物品和一个容量为V的背包，<strong>每种物品都有无限件可用</strong>。第i种物品的体积是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p></blockquote><h4 id="（1）二维数组"><a href="#（1）二维数组" class="headerlink" title="（1）二维数组"></a>（1）二维数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 105</span><br><span class="hljs-type">int</span> dp[MAXSIZE][MAXSIZE];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DP_CompleteBag</span><span class="hljs-params">(<span class="hljs-type">int</span> dp[][MAXSIZE], <span class="hljs-type">int</span> v[], <span class="hljs-type">int</span> w[], <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> V)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++) &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][j - v[i]] + w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[N][V];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);<br>    <span class="hljs-type">int</span> v[MAXSIZE], w[MAXSIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">DP_CompleteBag</span>(dp, v, w, N, V);<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）二进制优化（一维数组）"><a href="#（2）二进制优化（一维数组）" class="headerlink" title="（2）二进制优化（一维数组）"></a>（2）二进制优化（一维数组）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 105</span><br><span class="hljs-type">int</span> dp[MAXSIZE];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DP_CompleteBag</span><span class="hljs-params">(<span class="hljs-type">int</span> dp[], <span class="hljs-type">int</span> v[], <span class="hljs-type">int</span> w[], <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j++) &#123;<br>            dp[j] = dp[j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j - v[i]] + w[i], dp[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[V];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N, V;<br>    <span class="hljs-type">int</span> v[MAXSIZE], w[MAXSIZE];<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">DP_CompleteBag</span>(dp, v, w, N, V);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3、部分背包"><a href="#1-3、部分背包" class="headerlink" title="1.3、部分背包"></a>1.3、部分背包</h3><p>部分背包问题常用贪心算法求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    ll w;<br>    ll v;<br>    <span class="hljs-type">double</span> sv;<br>&#125; Node;<br>Node test[<span class="hljs-number">1005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> </span>&#123;<br>    Node *aa = (Node *)a;<br>    Node *bb = (Node *)b;<br>    <span class="hljs-keyword">return</span> (aa-&gt;sv &gt; bb-&gt;sv ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k; <span class="hljs-comment">// n -&gt; 物品总数, k -&gt; 背包最大容积</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; test[i].v &gt;&gt; test[i].w;<br>        test[i].sv = <span class="hljs-number">1.0</span> * test[i].v / test[i].w;<br>    &#125;<br>    <span class="hljs-built_in">qsort</span>(test, n, <span class="hljs-built_in">sizeof</span>(Node), cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (test[i].w &lt; k) &#123;<br>            ans += test[i].v;<br>            k -= test[i].w;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans += test[i].sv * k;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4、切钢条问题"><a href="#1-4、切钢条问题" class="headerlink" title="1.4、切钢条问题"></a>1.4、切钢条问题</h3><h4 id="（1）自顶向下版本"><a href="#（1）自顶向下版本" class="headerlink" title="（1）自顶向下版本"></a>（1）自顶向下版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7fffffff</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a, b) (a &gt; b ? a : b)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MEMOIZED_CUT_ROD</span><span class="hljs-params">(<span class="hljs-type">int</span> *money, <span class="hljs-type">int</span> rodSize)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MEMOIZED_CUT_ROD_AUX</span><span class="hljs-params">(<span class="hljs-type">int</span> *money, <span class="hljs-type">int</span> *ans, <span class="hljs-type">int</span> rodSize)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MEMOIZED_CUT_ROD</span><span class="hljs-params">(<span class="hljs-type">int</span> *money, <span class="hljs-type">int</span> rodSize)</span> </span>&#123;<br>    <span class="hljs-type">int</span> *ans = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (rodSize + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (rodSize + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">MEMOIZED_CUT_ROD_AUX</span>(money, ans, rodSize);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MEMOIZED_CUT_ROD_AUX</span><span class="hljs-params">(<span class="hljs-type">int</span> *money, <span class="hljs-type">int</span> *ans, <span class="hljs-type">int</span> rodSize)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (ans[rodSize] &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans[rodSize];<br>    <span class="hljs-keyword">if</span> (rodSize == <span class="hljs-number">0</span>) res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= rodSize; i++) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, money[i] + <span class="hljs-built_in">MEMOIZED_CUT_ROD_AUX</span>(money, ans, rodSize - i));<br>        &#125;<br>    &#125;<br>    ans[rodSize] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//钱从1开始，输入时从1开始输入即可。</span><br>    <span class="hljs-type">int</span> money[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>, <span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> maxAnswer = <span class="hljs-built_in">MEMOIZED_CUT_ROD</span>(money, <span class="hljs-number">9</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, maxAnswer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）自底向上版本"><a href="#（2）自底向上版本" class="headerlink" title="（2）自底向上版本"></a>（2）自底向上版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7fffffff</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a, b) (a &gt; b ? a : b)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BOTTOM_UP_CUT_ROD</span><span class="hljs-params">(<span class="hljs-type">int</span> *money, <span class="hljs-type">int</span> rodSize)</span> </span>&#123;<br>    <span class="hljs-type">int</span> *ans = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (rodSize + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(ans));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= rodSize; i++) &#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, money[j] + ans[i - j]);<br>        &#125;<br>        ans[i] = res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans[rodSize];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//钱从1开始，输入时从1开始输入即可。</span><br>    <span class="hljs-type">int</span> money[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>, <span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span> maxAnswer = <span class="hljs-built_in">BOTTOM_UP_CUT_ROD</span>(money, <span class="hljs-number">9</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, maxAnswer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5、最长公共子序列（LCS）"><a href="#1-5、最长公共子序列（LCS）" class="headerlink" title="1.5、最长公共子序列（LCS）"></a>1.5、最长公共子序列（LCS）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// LCS:longest-common-subsequence(最长公共子序列)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-comment">// 假设两个字符串的长度都不超过100</span><br><span class="hljs-type">int</span> len[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>]; <span class="hljs-comment">// dis[100][100]中1代表导论书中的左上箭头,2代表坐,3代表上</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LCS_Length</span><span class="hljs-params">(<span class="hljs-type">char</span> str1[], <span class="hljs-type">char</span> str2[])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Print_LCS</span><span class="hljs-params">(<span class="hljs-type">int</span> len1, <span class="hljs-type">int</span> len2, <span class="hljs-type">char</span> str1[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, str1, str2);<br>    LCS_Length(str1, str2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">LCS_Length</span><span class="hljs-params">(<span class="hljs-type">char</span> str1[], <span class="hljs-type">char</span> str2[])</span> &#123;<br>    <span class="hljs-type">int</span> len1 = <span class="hljs-built_in">strlen</span>(str1);<br>    <span class="hljs-type">int</span> len2 = <span class="hljs-built_in">strlen</span>(str2);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len1; i++) &#123;<br>        dis[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= len2; j++) &#123;<br>        dis[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>            <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) &#123;<br>                len[i][j] = len[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                dis[i][j] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len[i - <span class="hljs-number">1</span>][j] &gt;= len[i][j - <span class="hljs-number">1</span>]) &#123;<br>                len[i][j] = len[i - <span class="hljs-number">1</span>][j];<br>                dis[i][j] = <span class="hljs-number">3</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                len[i][j] = len[i][j - <span class="hljs-number">1</span>];<br>                dis[i][j] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// len[m][n]即为LCS的长度</span><br>    Print_LCS(len1, len2, str1);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Print_LCS</span><span class="hljs-params">(<span class="hljs-type">int</span> len1, <span class="hljs-type">int</span> len2, <span class="hljs-type">char</span> str1[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span> || len2 == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dis[len1][len2] == <span class="hljs-number">1</span>) &#123;<br>        Print_LCS(len1 - <span class="hljs-number">1</span>, len2 - <span class="hljs-number">1</span>, str1);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, str1[len1 - <span class="hljs-number">1</span>]);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[len1][len2] == <span class="hljs-number">3</span>) &#123;<br>        Print_LCS(len1 - <span class="hljs-number">1</span>, len2, str1);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Print_LCS(len1, len2 - <span class="hljs-number">1</span>, str1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6、最大子列和"><a href="#1-6、最大子列和" class="headerlink" title="1.6、最大子列和"></a>1.6、最大子列和</h3><h4 id="（1）相邻子列的和的最大值"><a href="#（1）相邻子列的和的最大值" class="headerlink" title="（1）相邻子列的和的最大值"></a>（1）相邻子列的和的最大值</h4><blockquote><p>给定一个数组，求这个数组中连续的子列的最大和</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxsize = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> num[maxsize];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSumDP</span><span class="hljs-params">(<span class="hljs-type">int</span> *num, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> Max=<span class="hljs-number">-2147483647</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (num[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>            dp = num[i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp += num[i];<br>        &#125;<br>        Max = <span class="hljs-built_in">max</span>(dp, Max);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Max;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; num[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">maxSumDP</span>(num, n) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）不相邻子列的和的最大值"><a href="#（2）不相邻子列的和的最大值" class="headerlink" title="（2）不相邻子列的和的最大值"></a>（2）不相邻子列的和的最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxsize = <span class="hljs-number">1005</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSumDP</span><span class="hljs-params">(<span class="hljs-type">int</span> *num, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> dp[maxsize];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    dp[<span class="hljs-number">0</span>] = num[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> ans1 = dp[i - <span class="hljs-number">2</span>] + num[i];<br>        <span class="hljs-type">int</span> ans2 = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], num[i]);<br>        dp[i] = <span class="hljs-built_in">max</span>(ans1, ans2);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> num[maxsize];<br>    <span class="hljs-built_in">memset</span>(num, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(num));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; num[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">maxSumDP</span>(num, n) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-7、矩阵链乘法（MCM）"><a href="#1-7、矩阵链乘法（MCM）" class="headerlink" title="1.7、矩阵链乘法（MCM）"></a>1.7、矩阵链乘法（MCM）</h3><blockquote><p>设<code>A1 ,A2 , … ,An</code>为矩阵序列， <code>Ai</code>为 <code>Pi-1 X Pi</code> 阶矩阵，<code>i = 1, 2, … , n</code>。 试确定矩阵的乘法顺序，使得元素相乘的总次数最少。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> intmax = <span class="hljs-number">2147483647</span>;<br><span class="hljs-comment">// M为存储矩阵边的数组的大小，M=n+1（n为矩阵个数）</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> M = <span class="hljs-number">8</span>;<br><span class="hljs-comment">// Length为存储边的数组的长度，n=Length-1为矩阵个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MatrixChainOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> Length, <span class="hljs-type">int</span> m[][M], <span class="hljs-type">int</span> s[][M])</span> </span>&#123;<br>    <span class="hljs-type">int</span> q, n = Length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)   m[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化矩阵m[i][i]都为0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++) <span class="hljs-comment">// l为要拆成的矩阵链的长度 &#123;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - l + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">//为什么j=i+l-1呢，因为矩阵链长度最大为l,所以根据i我们可以得到j</span><br>            <span class="hljs-type">int</span> j = i + l - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// m[i][j]初始值为0，因为后面要比较m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j] 和m[i][j]谁更小，所以我们在这里给m[i][j]赋一个很大的值</span><br>            m[i][j] = intmax;<br>            <span class="hljs-comment">//比较m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j] 和m[i][j]谁小</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt;= j - <span class="hljs-number">1</span>; k++) &#123;<br>                q = m[i][k] + m[k + <span class="hljs-number">1</span>][j] + p[i - <span class="hljs-number">1</span>] * p[k] * p[j];<br>                <span class="hljs-comment">//如果m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]更小（所需乘法次数更少），那么就更新m[i][j]=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j],并且将此时的k值储存在s[i][j]中</span><br>                <span class="hljs-keyword">if</span> (q &lt; m[i][j]) &#123;<br>                    m[i][j] = q;<br>                    s[i][j] = k;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>][n]; <span class="hljs-comment">//最后结果</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s[][M], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == j)<br>        cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; i;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span>;<br>        <span class="hljs-built_in">PrintPath</span>(s, i, s[i][j]);<br>        <span class="hljs-built_in">PrintPath</span>(s, s[i][j] + <span class="hljs-number">1</span>, j);<br>        cout &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> p[M] = &#123;<span class="hljs-number">30</span>, <span class="hljs-number">35</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// 7个矩阵，但是存了8个边</span><br>    <span class="hljs-type">int</span> m[M][M], s[M][M];<br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">MatrixChainOrder</span>(p, M, m, s);<br>    cout &lt;&lt; <span class="hljs-string">&quot;the optimal solution in seven matrix: \n&quot;</span><br>         &lt;&lt; k &lt;&lt; endl;<br>    <span class="hljs-built_in">PrintPath</span>(s, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、Greedy"><a href="#2、Greedy" class="headerlink" title="2、Greedy"></a>2、Greedy</h2><h3 id="2-1、活动选择"><a href="#2-1、活动选择" class="headerlink" title="2.1、活动选择"></a>2.1、活动选择</h3><blockquote><p>设<code>S = &#123;1,2,..,n&#125;</code> 为活动集合，<code>si</code>和<code>fi</code>分为活动i的开始时间和截止时间<code>,i=1,2,..n</code>。定义活动i与j相容等价于<code>si ≥ fj</code> 或 <code>sj ≥ fi</code> ，<code>i ≠ j</code> ，求S的最大的两两相容的活动子集A。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> startTime;<br>    <span class="hljs-type">int</span> endTime;<br>    <span class="hljs-type">int</span> index;<br>&#125; Activity;<br>Activity activity[<span class="hljs-number">100</span>];<br>Activity select[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> </span>&#123;<br>    Activity *p1 = (Activity *)a;<br>    Activity *p2 = (Activity *)b;<br>    <span class="hljs-keyword">return</span> p1-&gt;endTime - p2-&gt;endTime;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">greedySelector</span><span class="hljs-params">(<span class="hljs-type">int</span> n, Activity activity[], Activity select[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    select[<span class="hljs-number">1</span>].startTime = activity[<span class="hljs-number">1</span>].startTime;<br>    select[<span class="hljs-number">1</span>].endTime = activity[<span class="hljs-number">1</span>].endTime;<br>    select[<span class="hljs-number">1</span>].index = activity[<span class="hljs-number">1</span>].index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (activity[i].startTime &gt;= select[j].endTime) &#123;<br>            select[++j].startTime = activity[i].startTime;<br>            select[j].endTime = activity[i].endTime;<br>            select[j].index = activity[i].index;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;activity[i].startTime, &amp;activity[i].endTime);<br>        activity[i].index = i;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">qsort</span>(activity, n + <span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(Activity), cmp);<br>    <span class="hljs-built_in">greedySelector</span>(n, activity, select);<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">greedySelector</span>(n, activity, select);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, select[i].index);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、Graph"><a href="#3、Graph" class="headerlink" title="3、Graph"></a>3、Graph</h2><h3 id="3-1、链式前向星"><a href="#3-1、链式前向星" class="headerlink" title="3.1、链式前向星"></a>3.1、链式前向星</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 1005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_MAX 1005</span><br><span class="hljs-comment">//链式前向星的定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> from, to, w; <span class="hljs-comment">//w -&gt; weight</span><br>    <span class="hljs-type">int</span> next;        <span class="hljs-comment">// 表示与这个边起点相同的上一个边的编号</span><br>&#125; edge[E_MAX];<br><span class="hljs-type">int</span> head[V_MAX]; <span class="hljs-comment">// head[i] -&gt; 表示以i为起点的最后一条边的编号</span><br><span class="hljs-comment">// head[]一般初始化为-1</span><br><span class="hljs-comment">// addEdge operation</span><br><span class="hljs-comment">// 需要一个变量来记录边的编号 -&gt; cnt</span><br><span class="hljs-type">int</span> cnt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>    edge[cnt].from = from;<br>    edge[cnt].to = to;<br>    edge[cnt].w = w;<br>    edge[cnt].next = head[from];<br>    head[from] = cnt++;<br>&#125;<br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        head[i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    cnt = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//链式前向星的遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ergodic</span><span class="hljs-params">(<span class="hljs-type">int</span> v_num)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v_num; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;the edge start from :&quot;</span> &lt;&lt; i &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[i]; j != <span class="hljs-number">-1</span>; j = edge[j].next) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; edge[j].to &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; edge[j].w &lt;&lt; endl;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-built_in">addEdge</span>(u, v, w);<br>    &#125;<br>    <span class="hljs-built_in">ergodic</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2、Dijkstra"><a href="#3-2、Dijkstra" class="headerlink" title="3.2、Dijkstra"></a>3.2、Dijkstra</h3><h4 id="（1）普通"><a href="#（1）普通" class="headerlink" title="（1）普通"></a>（1）普通</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 100005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> num[<span class="hljs-number">2505</span>][<span class="hljs-number">2505</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    ll weight;<br>&#125;;<br>vector&lt;Edge&gt; e[V_MAX];<br>ll dis[V_MAX];<br><span class="hljs-type">bool</span> vis[V_MAX];<br><span class="hljs-comment">//标记的记号</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, ll w)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// n个顶点，m条边， s是单源最短路径的起点</span><br>    <span class="hljs-built_in">memset</span>(num, INF, <span class="hljs-built_in">sizeof</span>(num));<br>    <span class="hljs-type">int</span> s, t;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-type">int</span> x, y;<br>    ll w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;<br>        <span class="hljs-keyword">if</span> (w &lt; num[x][y]) &#123;<br>            num[x][y] = w;<br>            num[y][x] = w;<br>            <span class="hljs-built_in">addEdge</span>(x, y, w);<br>            <span class="hljs-built_in">addEdge</span>(y, x, w);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>(s);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, dis[t]);  <span class="hljs-comment">// 最短路保存在 dis 中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, ll w)</span> </span>&#123;<br>    e[u].<span class="hljs-built_in">push_back</span>(&#123;v, w&#125;);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, INF, <span class="hljs-built_in">sizeof</span>(dis));<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        ll minDis = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; minDis) &#123;<br>                u = j;<br>                minDis = dis[j];<br>            &#125;<br>        vis[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed : e[u]) &#123;<br>            <span class="hljs-type">int</span> v = ed.to;<br>            ll w = ed.weight;<br>            <span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w)<br>                dis[v] = dis[u] + w;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）堆优化"><a href="#（2）堆优化" class="headerlink" title="（2）堆优化"></a>（2）堆优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 100005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    ll w;<br>&#125;; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    ll dis;<br>    <span class="hljs-type">int</span> u;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Node &amp;b) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> dis &gt; b.dis; &#125;<br>&#125;;<br>vector&lt;Edge&gt; e[V_MAX];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, ll w)</span> </span>&#123;<br>    e[u].<span class="hljs-built_in">push_back</span>(&#123;v, w&#125;);<br>&#125;<br><span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; q;<br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dis</span><span class="hljs-params">(V_MAX)</span></span>;<br>    <span class="hljs-built_in">fill</span>(dis.<span class="hljs-built_in">begin</span>(), dis.<span class="hljs-built_in">end</span>(), INF);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(V_MAX)</span></span>;<br>    dis[s] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().u;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (vis[u])<br>            <span class="hljs-keyword">continue</span>;<br>        vis[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed : e[u]) &#123;<br>            <span class="hljs-type">int</span> v = ed.to;<br>            ll w = ed.w;<br>            <span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;<br>                dis[v] = dis[u] + w;<br>                q.<span class="hljs-built_in">push</span>(&#123;dis[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dis;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-type">int</span> s;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br>    <span class="hljs-type">int</span> x, y, w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;<br>        <span class="hljs-built_in">addEdge</span>(x, y, w); <span class="hljs-comment">// 有向图加一条边，无向图起点终点互换，再添加</span><br>    &#125;<br>    vector&lt;ll&gt; dis = <span class="hljs-built_in">dijkstra</span>(s);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cout &lt;&lt; dis[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3、Bellman-Ford"><a href="#3-3、Bellman-Ford" class="headerlink" title="3.3、Bellman-Ford"></a>3.3、Bellman-Ford</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> V_Max = <span class="hljs-number">1005</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> from, to;<br>    ll weight;<br>&#125; edges[V_Max];<br><span class="hljs-type">int</span> n, m;<br>ll dist[V_Max];<br>ll last[V_Max];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        dist[i] = INF;<br>    &#125;<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k++)<br>            <span class="hljs-keyword">if</span> (dist[edges[k].to] &gt; dist[edges[k].from] + edges[k].weight)<br>                dist[edges[k].to] = dist[edges[k].from] + edges[k].weight;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        edges[i] = &#123;u, v, w&#125;; <span class="hljs-comment">// 加边同dij</span><br>    &#125;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cout &lt;&lt; dist[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4、Floyd"><a href="#3-4、Floyd" class="headerlink" title="3.4、Floyd"></a>3.4、Floyd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 510 <span class="hljs-comment">// 结点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll f[V_MAX][V_MAX]; <span class="hljs-comment">// 邻接矩阵存图</span><br>ll p[V_MAX][V_MAX]; <span class="hljs-comment">// 邻接矩阵存中间节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//记得对邻接矩阵存中间节点进行初始化。</span><br>    <span class="hljs-comment">//初始化为p[x][y] = y;</span><br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) <span class="hljs-comment">// k代表中间节点</span><br>        <span class="hljs-keyword">for</span> (x = <span class="hljs-number">1</span>; x &lt;= n; x++)<br>            <span class="hljs-keyword">for</span> (y = <span class="hljs-number">1</span>; y &lt;= n; y++) &#123;<br>                <span class="hljs-keyword">if</span> ((f[x][y] &gt; f[x][k] + f[k][y] &amp;&amp; x != y)) &#123;<br>                    f[x][y] = f[x][k] + f[k][y];<br>                    p[x][y] = p[x][k];<br>                &#125;<br>            &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, t;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;<br>    <span class="hljs-comment">//初始化的过程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            f[i][j] = INF;<br>            p[i][j] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        f[i][i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> x, y, w;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;<br>        <span class="hljs-keyword">if</span> (w &lt; f[x][y])<br>            f[x][y] = w;<br>    &#125;<br>    <span class="hljs-built_in">Floyd</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-type">int</span> k = p[x][y];<br>        <span class="hljs-keyword">if</span> (f[x][y] != INF)<br>            cout &lt;&lt; f[x][y] &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-comment">//打印路径经过的点</span><br>        <span class="hljs-comment">//打印起点</span><br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        k = p[x][y];<br>        <span class="hljs-keyword">while</span> (k != y) &#123;<br>            cout &lt;&lt; k &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            k = p[k][y];<br>        &#125;<br>        cout &lt;&lt; y &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5、Kruskal-MST"><a href="#3-5、Kruskal-MST" class="headerlink" title="3.5、Kruskal_MST"></a>3.5、Kruskal_MST</h3><blockquote><p><code>Kruskal</code>算法 -&gt; 求解最小生成树的算法</p><p>核心在于将图中所有的边以权值为关键字进行排序，然后从小到大依次取出边，如果和已经插入的边不会形成环，则加入最小生成树<br>最小生成树的边数为<code>N - 1</code><br><code>Kruskal</code>算法的用到了一种高效的数据结构 -&gt; 并查集</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 300050</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_MAX 500050</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> x, y, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge &amp;b) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> w &lt; b.w; &#125;<br>&#125; edge[E_MAX];<br><span class="hljs-type">int</span> f[V_MAX];<br><span class="hljs-type">int</span> h[V_MAX];<br><span class="hljs-type">int</span> n, m, w;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        f[i] = i;<br>        h[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f[i] == i ? f[i] : f[i] = <span class="hljs-built_in">Find</span>(f[i]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> fa = <span class="hljs-built_in">Find</span>(a);<br>    <span class="hljs-type">int</span> fb = <span class="hljs-built_in">Find</span>(b);<br>    <span class="hljs-keyword">if</span> (fa == fb)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (h[fa] &lt; h[fb]) &#123;<br>        f[fa] = fb;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        f[fb] = fa;<br>        <span class="hljs-keyword">if</span> (h[fa] == h[fb]) h[fa]++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].w;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(edge, edge + m);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; cnt &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Find</span>(edge[i].x) == <span class="hljs-built_in">Find</span>(edge[i].y))<br>            <span class="hljs-keyword">continue</span>;<br>        cnt++;<br>        sum += edge[i].w;<br>        <span class="hljs-built_in">merge</span>(edge[i].x, edge[i].y);<br>    &#125;<br>    cout &lt;&lt; sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6、Prim-MST"><a href="#3-6、Prim-MST" class="headerlink" title="3.6、Prim_MST"></a>3.6、Prim_MST</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f7f7f7f</span><br><span class="hljs-type">int</span> n, G[MAXN][MAXN];<br><span class="hljs-type">int</span> d[MAXN];              <span class="hljs-comment">// 顶点与集合S的最短距离</span><br><span class="hljs-type">bool</span> vis[MAXN] = &#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">// 标记数组，相当于集合S</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 默认0号为初始点，函数返回最小生成树的边权之和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++) d[i] = INF; <span class="hljs-comment">// 整个d数组赋为INF</span><br>    d[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, MIN = INF; <span class="hljs-comment">// u使d[u]最小，MIN存放该最小的d[u]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (vis[j] == <span class="hljs-literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;<br>                u = j;<br>                MIN = d[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若找不到小于INF的d[u]，则剩下的顶点和集合S不连通</span><br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vis[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记u为已访问过</span><br>        ans += d[u];   <span class="hljs-comment">// 将与集合S举例最小的边加入最小生成树</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>            <span class="hljs-comment">// v未访问 &amp;&amp; 以u为中介可以使v离集合S更近</span><br>            <span class="hljs-keyword">if</span> (vis[v] == <span class="hljs-literal">false</span> &amp;&amp; G[u][v] &lt; d[v]) &#123;<br>                d[v] = G[u][v];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans; <span class="hljs-comment">// 返回最小生成树的边权之和</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7、Kahn-TopoSort"><a href="#3-7、Kahn-TopoSort" class="headerlink" title="3.7、Kahn_TopoSort"></a>3.7、Kahn_TopoSort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 100005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_MAX 200005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 1e9</span><br><span class="hljs-type">int</span> id[V_MAX]; <span class="hljs-comment">// in-degree</span><br>vector&lt;<span class="hljs-type">int</span>&gt; edge[V_MAX];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        id[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        edge[i].<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> from, to;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;from, &amp;to);<br>        id[to]++;<br>        edge[from].<span class="hljs-built_in">push_back</span>(to);<br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (id[i] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        ans.<span class="hljs-built_in">push_back</span>(p);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edge[p].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> y = edge[p][i];<br>            id[y]--;<br>            <span class="hljs-keyword">if</span> (id[y] == <span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() == n) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;topoSort Succeed!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;topoSort Failed!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7、Dinic-MaxFlow"><a href="#3-7、Dinic-MaxFlow" class="headerlink" title="3.7、Dinic_MaxFlow"></a>3.7、Dinic_MaxFlow</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 105</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_MAX 5005</span><br><span class="hljs-type">const</span> ll INF = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br>ll max_flow = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> E_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n, m, s, t; <span class="hljs-comment">// n -&gt; v_num, m -&gt; e_num, s -&gt; source, t -&gt; sink</span><br><span class="hljs-comment">// using chain-forward-star to store</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> next;<br>    ll val;<br>&#125; edge[E_MAX * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> head[V_MAX];<br><span class="hljs-type">int</span> depth[V_MAX];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>    edge[E_cnt].to = v;<br>    edge[E_cnt].val = w;<br>    edge[E_cnt].next = head[u];<br>    head[u] = E_cnt++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> u, v;<br>    ll w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        <span class="hljs-built_in">addEdge</span>(u, v, w);<br>        <span class="hljs-built_in">addEdge</span>(v, u, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(depth));<br>    depth[s] = <span class="hljs-number">1</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = edge[i].next) &#123;<br>            <span class="hljs-type">int</span> v = edge[i].to;<br>            <span class="hljs-keyword">if</span> (edge[i].val &amp;&amp; !depth[v]) &#123;<br>                depth[v] = depth[u] + i;<br>                q.<span class="hljs-built_in">push</span>(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (depth[t] != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, ll in)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos == t) &#123;<br>        <span class="hljs-keyword">return</span> in;<br>    &#125;<br>    ll out = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = head[pos]; u &gt; <span class="hljs-number">-1</span> &amp;&amp; in; u = edge[u].next) &#123;<br>        <span class="hljs-type">int</span> v = edge[u].to;<br>        <span class="hljs-keyword">if</span> (edge[u].val &amp;&amp; depth[v] == depth[pos] + <span class="hljs-number">1</span>) &#123;<br>            ll res = <span class="hljs-built_in">DFS</span>(v, <span class="hljs-built_in">min</span>(edge[u].val, in));<br>            edge[u].val -= res;<br>            edge[u ^ <span class="hljs-number">1</span>].val += res;<br>            in -= res;<br>            out += res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (out == <span class="hljs-number">0</span>)<br>        depth[pos] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">Dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">BFS</span>()) &#123;<br>        max_flow += <span class="hljs-built_in">DFS</span>(s, INF);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_flow;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-built_in">fill</span>(head + <span class="hljs-number">1</span>, head + <span class="hljs-number">1</span> + n, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">read</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">Dinic</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8、二分图匹配"><a href="#3-8、二分图匹配" class="headerlink" title="3.8、二分图匹配"></a>3.8、二分图匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">500</span>;<br><span class="hljs-type">int</span> uN, vN;         <span class="hljs-comment">// u, v数目，要初始化！！！</span><br><span class="hljs-type">bool</span> g[MAXN][MAXN]; <span class="hljs-comment">// g[i][j] 表示xi与yj相连</span><br><span class="hljs-type">int</span> w[<span class="hljs-number">4</span>][MAXN];<br><span class="hljs-type">int</span> xM[MAXN], yM[MAXN]; <span class="hljs-comment">// 输出量</span><br><span class="hljs-type">bool</span> chk[MAXN];         <span class="hljs-comment">// 辅助量检查某轮y[v]是否被check</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SearchPath</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">for</span> (v = <span class="hljs-number">0</span>; v &lt; vN; v++)<br>        <span class="hljs-keyword">if</span> (g[u][v] &amp;&amp; !chk[v]) &#123;<br>            chk[v] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (yM[v] == <span class="hljs-number">-1</span> || <span class="hljs-built_in">SearchPath</span>(yM[v])) &#123;<br>                yM[v] = u;<br>                xM[u] = v;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MaxMatch</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> u, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(xM, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(xM));<br>    <span class="hljs-built_in">memset</span>(yM, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(yM));<br>    <span class="hljs-keyword">for</span> (u = <span class="hljs-number">0</span>; u &lt; uN; u++)<br>        <span class="hljs-keyword">if</span> (xM[u] == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">memset</span>(chk, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(chk));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SearchPath</span>(u))<br>                ret++;<br>        &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (w[<span class="hljs-number">1</span>][i] &lt;= w[<span class="hljs-number">2</span>][j] &amp;&amp; w[<span class="hljs-number">0</span>][i] &gt;= w[<span class="hljs-number">3</span>][j])<br>                g[i][j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    uN = vN = n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">MaxMatch</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、计算几何"><a href="#4、计算几何" class="headerlink" title="4、计算几何"></a>4、计算几何</h2><h3 id="4-1、线段相交"><a href="#4-1、线段相交" class="headerlink" title="4.1、线段相交"></a>4.1、线段相交</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Judge whether two given line segments intersect</span><br><span class="hljs-comment">// p1 (x1, y1), p2 (x2, y2);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;<br>    &#125;<br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;<br>    &#125;<br>    <span class="hljs-comment">//横纵坐标同时乘以常数b</span><br>    Point <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x * b, y * b&#125;;<br>    &#125;<br>    <span class="hljs-comment">//两个点的叉积</span><br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> x * b.y - y * b.x;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segment</span> &#123;<br>    Point p1;<br>    Point p2;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(Point p, segment l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p.x &gt;= <span class="hljs-built_in">min</span>(l.p1.x, l.p2.x) &amp;&amp;<br>        p.x &lt;= <span class="hljs-built_in">max</span>(l.p1.x, l.p2.x) &amp;&amp;<br>        p.y &gt;= <span class="hljs-built_in">min</span>(l.p1.y, l.p2.y) &amp;&amp;<br>        p.y &lt;= <span class="hljs-built_in">max</span>(l.p1.y, l.p2.y))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(segment l1, segment l2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> d1 = (l1.p2 - l1.p1) ^ (l2.p1 - l1.p1);<br>    <span class="hljs-type">int</span> d2 = (l1.p2 - l1.p1) ^ (l2.p2 - l1.p1);<br>    <span class="hljs-type">int</span> d3 = (l2.p2 - l2.p1) ^ (l1.p1 - l2.p1);<br>    <span class="hljs-type">int</span> d4 = (l2.p2 - l2.p1) ^ (l1.p2 - l2.p1);<br>    <span class="hljs-keyword">if</span> (d1 * d2 &lt; <span class="hljs-number">0</span> &amp;&amp; d3 * d4 &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (d1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l2.p1, l1))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (d2 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l2.p2, l1))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (d3 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l1.p1, l2))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (d4 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l1.p2, l2))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x1, y1, x2, y2;<br>    segment l1;<br>    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>    l1 = &#123;&#123;x1, y1&#125;, &#123;x2, y2&#125;&#125;;<br>    segment l2;<br>    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>    l2 = &#123;&#123;x1, y1&#125;, &#123;x2, y2&#125;&#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">intersect</span>(l1, l2)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;intersect!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;not intersect!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2、线段相交计数"><a href="#4-2、线段相交计数" class="headerlink" title="4.2、线段相交计数"></a>4.2、线段相交计数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// cal the number</span><br><span class="hljs-comment">// p1 (x1, y1), p2 (x2, y2);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;<br>    &#125;<br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;<br>    &#125;<br>    <span class="hljs-comment">//横纵坐标同时乘以常数b</span><br>    Point <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x * b, y * b&#125;;<br>    &#125;<br>    <span class="hljs-comment">//两个点的叉积</span><br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> x * b.y - y * b.x;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segment</span> &#123;<br>    Point p1;<br>    Point p2;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(Point p, segment l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p.x &gt;= <span class="hljs-built_in">min</span>(l.p1.x, l.p2.x) &amp;&amp;<br>        p.x &lt;= <span class="hljs-built_in">max</span>(l.p1.x, l.p2.x) &amp;&amp;<br>        p.y &gt;= <span class="hljs-built_in">min</span>(l.p1.y, l.p2.y) &amp;&amp;<br>        p.y &lt;= <span class="hljs-built_in">max</span>(l.p1.y, l.p2.y))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(segment l1, segment l2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> d1 = (l1.p2 - l1.p1) ^ (l2.p1 - l1.p1);<br>    <span class="hljs-type">int</span> d2 = (l1.p2 - l1.p1) ^ (l2.p2 - l1.p1);<br>    <span class="hljs-type">int</span> d3 = (l2.p2 - l2.p1) ^ (l1.p1 - l2.p1);<br>    <span class="hljs-type">int</span> d4 = (l2.p2 - l2.p1) ^ (l1.p2 - l2.p1);<br>    <span class="hljs-keyword">if</span> (d1 * d2 &lt; <span class="hljs-number">0</span> &amp;&amp; d3 * d4 &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (d1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l2.p1, l1))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (d2 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l2.p2, l1))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (d3 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l1.p1, l2))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (d4 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l1.p2, l2))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>vector&lt;segment&gt; segments;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x1, y1, x2, y2;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        segments.<span class="hljs-built_in">push_back</span>(&#123;&#123;x1, y1&#125;, &#123;x2, y2&#125;&#125;);<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">intersect</span>(segments[i], segments[j])) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3、Graham-凸包"><a href="#4-3、Graham-凸包" class="headerlink" title="4.3、Graham 凸包"></a>4.3、Graham 凸包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 200005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eps 1e-7</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;<br>    &#125;<br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;<br>    &#125;<br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> x * b.y - y * b.x;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (x != b.x)<br>            <span class="hljs-keyword">return</span> x &lt; b.x;<br>        <span class="hljs-keyword">return</span> y &lt; b.y;<br>    &#125;<br>&#125;;<br>Point p[MAX];<br>Point stack[MAX];<br><span class="hljs-type">int</span> top;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortMin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a, Point b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point a, Point b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graham</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;<br>    &#125;<br>    <span class="hljs-built_in">sortMin</span>(n);<br>    <span class="hljs-built_in">sort</span>(p + <span class="hljs-number">1</span>, p + n, cmp);<br>    <span class="hljs-built_in">graham</span>(n);<br>    <span class="hljs-comment">// print the num of the vertex of tubao.</span><br>    cout &lt;&lt; top + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//获取这些点中位置最小的点。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortMin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    Point pMin = p[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> minId = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p[i] &lt; pMin) &#123;<br>            pMin = p[i];<br>            minId = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(p[<span class="hljs-number">0</span>], p[minId]);<br>&#125;<br><span class="hljs-comment">//定义排序规则</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a, Point b)</span> </span>&#123;<br>    <span class="hljs-type">double</span> x = (a - p[<span class="hljs-number">0</span>]) ^ (b - p[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">equal</span>(x, <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">dis</span>(a, p[<span class="hljs-number">0</span>]) &lt; <span class="hljs-built_in">dis</span>(b, p[<span class="hljs-number">0</span>])))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//定义double的equal规则</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt; eps;<br>&#125;<br><span class="hljs-comment">// The distance between two points;</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point a, Point b)</span> </span>&#123;<br>    <span class="hljs-type">double</span> x = a.x - b.x;<br>    <span class="hljs-type">double</span> y = a.y - b.y;<br>    <span class="hljs-keyword">return</span> x * x + y * y;<br>&#125;<br><span class="hljs-comment">// graham_scan</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graham</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    stack[<span class="hljs-number">0</span>] = p[<span class="hljs-number">0</span>];<br>    stack[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>];<br>    top = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span> &amp;&amp; ((p[i] - stack[top]) ^ (stack[top - <span class="hljs-number">1</span>] - stack[top])) &lt;= <span class="hljs-number">0</span>)<br>            top--;<br>        stack[++top] = p[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、其他算法"><a href="#5、其他算法" class="headerlink" title="5、其他算法"></a>5、其他算法</h2><h3 id="5-1、KMP字符串匹配"><a href="#5-1、KMP字符串匹配" class="headerlink" title="5.1、KMP字符串匹配"></a>5.1、KMP字符串匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(string str)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string text;<br>    string key;<br>    cin &gt;&gt; text;<br>    cin &gt;&gt; key;<br>    <span class="hljs-type">int</span> len1 = key.<span class="hljs-built_in">length</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; kmp = <span class="hljs-built_in">prefix</span>(key);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; text.<span class="hljs-built_in">length</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span> (k &amp;&amp; key[k] != text[i])<br>            k = kmp[k - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (text[i] == key[k])<br>            k++;<br>        <span class="hljs-keyword">if</span> (k == len1)<br>            cout &lt;&lt; i - k + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 匹配成功，返回key的text中出现的所有位置，下标从0开始</span><br>    &#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = str.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-type">int</span> j = pre[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; str[i] != str[j]) &#123;<br>            j = pre[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (str[i] == str[j])<br>            j++;<br>        pre[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2、FFT（常规）-多项式乘法"><a href="#5-2、FFT（常规）-多项式乘法" class="headerlink" title="5.2、FFT（常规）-多项式乘法"></a>5.2、FFT（常规）-多项式乘法</h3><blockquote><p>输入方式及含义：<br>$$<br>input:n,m\<br>f:f(0)<em>x^0 + f(1)</em>x^1 + f(2)<em>x^2 + …\<br>p:p(0)</em>x^0 + p(1)<em>x^1 + p(2)</em>x^2 + …\<br>ans = f * p<br>$$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max 5000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;<br>    &#125;<br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;<br>    &#125;<br>    Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;<br>    &#125;<br>&#125; f[Max], p[Max], sav[Max];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; f[i].x;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>        cin &gt;&gt; p[i].x;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (m += n, n = <span class="hljs-number">1</span>; n &lt;= m; n &lt;&lt;= <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dft</span>(f, n);<br>    <span class="hljs-built_in">dft</span>(p, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        f[i] = f[i] * p[i];<br>    &#125;<br>    <span class="hljs-built_in">idft</span>(f, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>        cout &lt;&lt; (<span class="hljs-type">int</span>)(f[i].x / n + <span class="hljs-number">0.49</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Complex *fl = f, *fr = f + len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        sav[i] = f[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">2</span>; i++) &#123;<br>        fl[i] = sav[i &lt;&lt; <span class="hljs-number">1</span>];<br>        fr[i] = sav[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-built_in">dft</span>(fl, len / <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">dft</span>(fr, len / <span class="hljs-number">2</span>);<br>    Complex tG = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * PI / len), <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * PI / len)&#125;;<br>    Complex buf = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">2</span>; i++) &#123;<br>        sav[i] = fl[i] + buf * fr[i];<br>        sav[i + len / <span class="hljs-number">2</span>] = fl[i] - buf * fr[i];<br>        buf = buf * tG;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        f[i] = sav[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Complex *fl = f, *fr = f + len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)<br>        sav[k] = f[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;<br>        fl[k] = sav[k &lt;&lt; <span class="hljs-number">1</span>];<br>        fr[k] = sav[k &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-built_in">idft</span>(fl, len / <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">idft</span>(fr, len / <span class="hljs-number">2</span>);<br>    Complex tG = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * PI / len), -<span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * PI / len)&#125;;<br>    Complex buf = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;<br>        sav[k] = fl[k] + buf * fr[k];<br>        sav[k + len / <span class="hljs-number">2</span>] = fl[k] - buf * fr[k];<br>        buf = buf * tG;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)<br>        f[k] = sav[k];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3、FFT（迭代）-多项式乘法"><a href="#5-3、FFT（迭代）-多项式乘法" class="headerlink" title="5.3、FFT（迭代）-多项式乘法"></a>5.3、FFT（迭代）-多项式乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e7</span> + <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            f = <span class="hljs-number">-1</span>;<br>        c = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        x = x * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        c = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">complex</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> xx = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> yy = <span class="hljs-number">0</span>) &#123; x = xx, y = yy; &#125;<br>&#125; a[MAXN], b[MAXN];<br>complex <span class="hljs-keyword">operator</span>+(complex a, complex b) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(a.x + b.x, a.y + b.y); &#125;<br>complex <span class="hljs-keyword">operator</span>-(complex a, complex b) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(a.x - b.x, a.y - b.y); &#125;<br>complex <span class="hljs-keyword">operator</span>*(complex a, complex b) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125; <span class="hljs-comment">//不懂的看复数的运算那部分</span><br><span class="hljs-type">int</span> N, M;<br><span class="hljs-type">int</span> l, r[MAXN];<br><span class="hljs-type">int</span> limit = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fast_fast_tle</span><span class="hljs-params">(complex *A, <span class="hljs-type">int</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; limit; i++)<br>        <span class="hljs-keyword">if</span> (i &lt; r[i])<br>            <span class="hljs-built_in">swap</span>(A[i], A[r[i]]); <span class="hljs-comment">// 求出要迭代的序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> mid = <span class="hljs-number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 待合并区间的长度的一半</span><br>        <span class="hljs-function">complex <span class="hljs-title">Wn</span><span class="hljs-params">(cos(Pi / mid), type * sin(Pi / mid))</span></span>; <span class="hljs-comment">// 单位根</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> R = mid &lt;&lt; <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; limit; j += R) &#123; <span class="hljs-comment">// R是区间的长度，j表示前已经到哪个位置了</span><br>            <span class="hljs-function">complex <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 幂</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; mid; k++, w = w * Wn) &#123; <span class="hljs-comment">// 枚举左半部分</span><br>                complex x = A[j + k], y = w * A[j + mid + k]; <span class="hljs-comment">// 蝴蝶效应</span><br>                A[j + k] = x + y;<br>                A[j + mid + k] = x - y;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-built_in">read</span>(), M = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>        a[i].x = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= M; i++)<br>        b[i].x = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span> (limit &lt;= N + M)<br>        limit &lt;&lt;= <span class="hljs-number">1</span>, l++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; limit; i++)<br>        r[i] = (r[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) | ((i &amp; <span class="hljs-number">1</span>) &lt;&lt; (l - <span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// 在原序列中 i 与 i/2 的关系是 ： i可以看做是i/2的二进制上的每一位左移一位得来</span><br>    <span class="hljs-comment">// 那么在反转后的数组中就需要右移一位，同时特殊处理一下奇数</span><br>    <span class="hljs-built_in">fast_fast_tle</span>(a, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">fast_fast_tle</span>(b, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= limit; i++)<br>        a[i] = a[i] * b[i];<br>    <span class="hljs-built_in">fast_fast_tle</span>(a, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= N + M; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (<span class="hljs-type">int</span>)(a[i].x / limit + <span class="hljs-number">0.5</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4、FFT-高精度乘法"><a href="#5-4、FFT-高精度乘法" class="headerlink" title="5.4、FFT-高精度乘法"></a>5.4、FFT-高精度乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">4000005</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;<br>    &#125;<br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;<br>    &#125;<br>    Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;<br>    &#125;<br>&#125; f[MAX], p[MAX], sav[MAX];<br>ll ans[MAX];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> a[MAX], b[MAX];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, a, b);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(a);<br>    <span class="hljs-type">int</span> m = <span class="hljs-built_in">strlen</span>(b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        f[i].x = a[n - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        p[i].x = b[m - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (m += n, n = <span class="hljs-number">1</span>; n &lt;= m; n &lt;&lt;= <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dft</span>(f, n);<br>    <span class="hljs-built_in">dft</span>(p, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        f[i] = f[i] * p[i];<br>    <span class="hljs-built_in">idft</span>(f, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)<br>        ans[i] = (ll) (f[i].x / n + <span class="hljs-number">0.49</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++)&#123;<br>        ans[i + <span class="hljs-number">1</span>] += (ans[i] / <span class="hljs-number">10</span>);<br>        ans[i] %= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> t = MAX - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (ans[t] == <span class="hljs-number">0</span>)<br>        t--;<br>    <span class="hljs-keyword">while</span> (t &gt;= <span class="hljs-number">0</span>)<br>        cout &lt;&lt; ans[t--];<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Complex *fl = f, *fr = f + len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)<br>        sav[k] = f[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;<br>        fl[k] = sav[k &lt;&lt; <span class="hljs-number">1</span>];<br>        fr[k] = sav[k &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-built_in">dft</span>(fl, len / <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">dft</span>(fr, len / <span class="hljs-number">2</span>);<br>    Complex tG = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * Pi / len), <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * Pi / len)&#125;;<br>    Complex buf = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;<br>        sav[k] = fl[k] + buf * fr[k];<br>        sav[k + len / <span class="hljs-number">2</span>] = fl[k] - buf * fr[k];<br>        buf = buf * tG;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)<br>        f[k] = sav[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Complex *fl = f, *fr = f + len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)<br>        sav[k] = f[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;<br>        fl[k] = sav[k &lt;&lt; <span class="hljs-number">1</span>];<br>        fr[k] = sav[k &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-built_in">idft</span>(fl, len / <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">idft</span>(fr, len / <span class="hljs-number">2</span>);<br>    Complex tG = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * Pi / len), -<span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * Pi / len)&#125;;<br>    Complex buf = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;<br>        sav[k] = fl[k] + buf * fr[k];<br>        sav[k + len / <span class="hljs-number">2</span>] = fl[k] - buf * fr[k];<br>        buf = buf * tG;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)<br>        f[k] = sav[k];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BUAA</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BUAA</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象程序设计-Java</title>
    <link href="/2023/01/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java/"/>
    <url>/2023/01/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java/</url>
    
    <content type="html"><![CDATA[<p>BUAA 软院 大二上 OOP课程总结</p><span id="more"></span><h1 id="面向对象程序设计-OOP"><a href="#面向对象程序设计-OOP" class="headerlink" title="面向对象程序设计(OOP)"></a>面向对象程序设计(OOP)</h1><h2 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h2><ul><li>两个基本概念：类(class)、对象(Object)</li></ul><ul><li>三大特征：封装、继承、多态</li></ul><h3 id="1、Java语言运行机制"><a href="#1、Java语言运行机制" class="headerlink" title="1、Java语言运行机制"></a>1、Java语言运行机制</h3><h4 id="1-1、JVM"><a href="#1-1、JVM" class="headerlink" title="1.1、JVM"></a>1.1、JVM</h4><p>Java 虚拟机是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。对于不同的平台有着不同的 JVM，只有某平台提供了对应的 Java 虚拟机，Java 程序才可以在这个平台上运行。</p><p>JVM 屏蔽底层运行平台的差别，可以实现<strong>“一次编译，到处运行“</strong></p><h4 id="1-2、Garbage-Collection"><a href="#1-2、Garbage-Collection" class="headerlink" title="1.2、Garbage Collection"></a>1.2、Garbage Collection</h4><p>Java 消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间.</p><p><strong>Tips：</strong>Java 程序即使可以实现垃圾的自动回收，但是依旧会出现内存泄漏和内存溢出问题。</p><p>但在Java中，依旧提供了<strong>内存强制回收机制</strong>。</p><p>Java 系统提供了方法<code>System.gc()</code>和<code>Runtime.gc()</code> 方法来强制立即回收垃圾(<strong>但系统并不保证会立即进行垃圾回收</strong>)。</p><p>判断一个存储单元是否是垃圾的依据：<strong>该存储单元所对应的对象是否仍被程序所用</strong>。而判断一个对象是否仍为程序所用的依据是：<strong>是否有引用指向该对象</strong>。</p><h3 id="2、对象"><a href="#2、对象" class="headerlink" title="2、对象"></a>2、对象</h3><ul><li>对象的特征：属性</li></ul><ul><li>属性是对象具有的各种特征，且每个对象的各个属性都具有特定值。</li></ul><ul><li>对象的动作：方法</li></ul><ul><li>对象执行的操作称之为方法</li></ul><h2 id="二、封装数据为类"><a href="#二、封装数据为类" class="headerlink" title="二、封装数据为类"></a>二、封装数据为类</h2><p>Java 允许在一个Java 源文件中编写多个类，但其中的多个类至多只能有一个类使用 public 修饰，并且这个类一般含有 main 方法。</p><h3 id="1、类的定义说明"><a href="#1、类的定义说明" class="headerlink" title="1、类的定义说明"></a>1、类的定义说明</h3><ul><li>关键字<code>class</code>表示类定义的开始</li><li>类名要符合标识符的命名规范</li><li>修饰符分为访问控制符和类型说明符<ul><li>类的访问控制符只有两个：<code>public</code>和默认</li><li>一个类被定义为公共类，那么它可以被其他所有的类访问和引用</li><li>不用<code>public</code>定义的类，只能被同一个包中定义的类访问和引用</li><li>类的类型说明符有两个：<code>final</code>和<code>abstract</code></li></ul></li></ul><h3 id="2、成员方法定义说明"><a href="#2、成员方法定义说明" class="headerlink" title="2、成员方法定义说明"></a>2、成员方法定义说明</h3><ul><li>常用修饰符：<code>public</code>、<code>private</code>、<code>protected</code>、<code>static</code>、<code>final</code></li></ul><h3 id="3、创建对象"><a href="#3、创建对象" class="headerlink" title="3、创建对象"></a>3、创建对象</h3><p>Java每个类都默认地具有<code>null</code>、<code>this</code>、<code>super</code>三个域，在任何类中都可以不加说明引用他们。</p><blockquote><p><code>null</code>：代表”空“，用在定义一个对象但没有为其开辟内存空间时。</p><p><code>this</code>&amp;<code>super</code>：指代<strong>本类对象</strong>和<strong>父类对象</strong>的关键字</p></blockquote><p><code>this</code>可以看作一个变量，它的值是当前对象的引用。在类的方法定义中，使用<code>this</code>关键字代表使用该方法的对象的引用。</p><p>使用<code>this</code>可以处理方法中成员变量和局部变量重名的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//example</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、深拷贝和浅拷贝"><a href="#4、深拷贝和浅拷贝" class="headerlink" title="4、深拷贝和浅拷贝"></a>4、深拷贝和浅拷贝</h3><p><strong>浅拷贝</strong>：浅拷贝是会将对象的每一个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时，也会跟着改变。</p><p><strong>深拷贝</strong>：深拷贝复制变量值，对于引用数据，则递归至基本类型后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p><blockquote><p><strong>基本类型</strong>作为参数传递 -&gt; 深拷贝</p><p><strong>引用类型</strong>作为参数传递 -&gt; 浅拷贝</p></blockquote><h3 id="5、方法的重载"><a href="#5、方法的重载" class="headerlink" title="5、方法的重载"></a>5、方法的重载</h3><p>方法的重载：指一个类中有多个<strong>名字相同</strong>，但<strong>参数不同</strong>的方法。</p><blockquote><h5 id="重载方法必须满足的条件："><a href="#重载方法必须满足的条件：" class="headerlink" title="重载方法必须满足的条件："></a>重载方法必须满足的条件：</h5><ul><li><p>方法名相同</p></li><li><p>方法的参数的类型，个数，顺序至少有一个不同</p></li><li><p>方法的返回类型可以不相同</p></li><li><p>方法的修饰符可以不相同</p><p>关于参数列表的顺序，Tips:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//error:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> b, <span class="hljs-type">int</span> a)</span>&#123;&#125; <br><span class="hljs-comment">//虽然参数列表中的变量名不同，但类型相同，本质上就是(int, int);</span><br><span class="hljs-comment">//right:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b)</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">int</span> b)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h3 id="6、构造方法"><a href="#6、构造方法" class="headerlink" title="6、构造方法"></a>6、构造方法</h3><p>构造方法：一类特殊的成员方法，用<code>new</code>关键字来对新生成的对象进行初始化。</p><blockquote><h5 id="构造方法必须满足的条件："><a href="#构造方法必须满足的条件：" class="headerlink" title="构造方法必须满足的条件："></a>构造方法必须满足的条件：</h5><ul><li>方法名与类同名</li><li>没有任何的返回值</li><li>语法结构与一般方法相同</li></ul></blockquote><p>一个类，至少会有一个构造方法，构造方法分为不带参数构造方法(<strong>默认构造方法</strong>)和带参数构造方法。</p><p>在使用构造方法时，会使用<code>new</code>关键字。其作用为：</p><blockquote><ul><li>为对象分配内存空间</li><li>引起对象构造方法的调用</li><li>为对象返回一个引用</li></ul></blockquote><p><strong>Tips:如果一个类没有显式的定义任何构造函数，系统将自动提供一个默认构造方法。该构造方法：没有参数，没有方法体。一旦在类中定义了一个构造函数，那么便不会自动提供一个默认构造方法。</strong></p><p><strong>构造方法也可以重载。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动提供的默认构造方法举例</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>即：如果类中提供的构造函数都不是无参数构造函数，却企图调用无参数构造函数初始化此类的对象，编译时会产生语法错误。</p><h3 id="7、对象构造顺序"><a href="#7、对象构造顺序" class="headerlink" title="7、对象构造顺序"></a>7、对象构造顺序</h3><p>用<code>new</code>语句创建类的对象时，Java虚拟机会从最上层的父类开始，依次执行各个父类以及当前类的构造方法，从而保证来自于对象本身以及从父类中继承的实例变量都被正确地初始化。即：<strong>先构造父类对象，再构造子类对象</strong>。</p><blockquote><ol><li>递归的构造父类对象</li><li>顺序地调用本类成员属性赋初值语句</li><li>本类的构造方法</li></ol></blockquote><h3 id="8、特殊的对象：匿名对象"><a href="#8、特殊的对象：匿名对象" class="headerlink" title="8、特殊的对象：匿名对象"></a>8、特殊的对象：匿名对象</h3><p>我们可以不定义对象的句柄，直接调用对象的方法，这样的对象叫做<strong>匿名对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匿名对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">//定义了一个对象，但是没有名字，称为匿名对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>().show(); <span class="hljs-comment">//匿名对象的方法的调用</span><br></code></pre></td></tr></table></figure><p><strong>Tips:匿名对象用完了之后就变成垃圾了，因为这个对象没有被栈内存中的变量指向，所以会被<code>gc</code>回收。</strong></p><p>匿名对象常作为一个实参传递给一个函数调用。</p><h3 id="9、类的访问机制以及类中变量的存储"><a href="#9、类的访问机制以及类中变量的存储" class="headerlink" title="9、类的访问机制以及类中变量的存储"></a>9、类的访问机制以及类中变量的存储</h3><blockquote><p><strong>在一个类中的访问机制：</strong>类中的方法可以直接访问类中的成员变量。</p><p><strong>在不同类中的访问机制：</strong>先创建访问类的对象，再用对象访问类中的成员变量。</p></blockquote><p>类中的变量分为：成员变量和局部变量</p><p><strong>成员变量</strong>存储在<strong>堆</strong>内存的对象中，所有成员变量<strong>具有默认的初始化值</strong>。</p><p><strong>局部变量</strong>存储在<strong>栈</strong>内存的对象中，局部变量<strong>没有默认的初始化值</strong>，必须<strong>手动赋值</strong>才可以使用。</p><h3 id="10、类的静态属性和静态方法（重点、难点）"><a href="#10、类的静态属性和静态方法（重点、难点）" class="headerlink" title="10、类的静态属性和静态方法（重点、难点）"></a>10、类的静态属性和静态方法（重点、难点）</h3><hr><p>程序运行时的内存占用：</p><table><thead><tr><th align="center">代码区（code area）</th><th align="center">存放程序的代码部分</th></tr></thead><tbody><tr><td align="center">数据区（data area）</td><td align="center">存放数据的全局数据和静态数据</td></tr><tr><td align="center">堆区（heap area）</td><td align="center">存放程序动态申请的数据</td></tr><tr><td align="center">栈区（stack area）</td><td align="center">存放程序的局部数据和参数</td></tr></tbody></table><p>在Java中，把<strong>代表类范围信息</strong>的变量和方法用<code>static</code>修饰。</p><p>当你把某一个变量或者方法用<code>static</code>修饰，它就不再局限于所属的<code>class Object</code>上了，即使没有创建该类的具体对象，类中的static类成员也会存在。</p><blockquote><ul><li>用<code>static</code>修饰的属性/变量称为静态属性/类变量</li><li>用<code>static</code>修饰的方法称为静态方法/类方法。<strong>在类方法里没有<code>this</code></strong></li><li>用<code>static</code>修饰的初始化语句块称为静态初始化语句块</li></ul></blockquote><p>静态方法和非静态方法的区别：</p><blockquote><ul><li>本质区别：静态方法在<strong>类定义时</strong>已经被装载和分配的（早加载）；而非静态方法在类定义是时没有占用内存，只有在<strong>类被实例化成对象时</strong>，对象调用该方法才被分配内存（晚加载）。</li><li>静态方法中只能调用静态成员和静态方法，不能调用非静态成员和非静态方法。非静态方法要被实例化才能被静态方法调用。</li></ul></blockquote><p><code>new</code>一个对象的语句执行顺序：</p><blockquote><h5 id="第一次new该类对象时："><a href="#第一次new该类对象时：" class="headerlink" title="第一次new该类对象时："></a>第一次<code>new</code>该类对象时：</h5><ul><li>初始化有显式初始化的 static 成员变量</li><li>按顺序执行 static 语句块</li><li>初始化有显式初始化的非 static 成员变量</li><li>按顺序执行非 static 语句块</li><li>调用构造函数</li></ul></blockquote><blockquote><h5 id="第二次再次new该类对象是："><a href="#第二次再次new该类对象是：" class="headerlink" title="第二次再次new该类对象是："></a>第二次再次<code>new</code>该类对象是：</h5><ul><li>初始化有显式初始化的非 static 成员变量</li><li>按照顺序执行非 static 语句块</li><li>调用构造函数</li></ul></blockquote><p>静态代码块只能定义在类里面，它独立于任何方法，不能定义在方法里面。</p><h2 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h2><p>“隐藏属性、方法或实现细节过程称为封装。”</p><blockquote><h5 id="Java中封装的体现："><a href="#Java中封装的体现：" class="headerlink" title="Java中封装的体现："></a>Java中封装的体现：</h5><ul><li>访问权限修饰符</li><li>类</li><li>package</li><li>系统</li></ul></blockquote><h3 id="1、访问控制修饰符"><a href="#1、访问控制修饰符" class="headerlink" title="1、访问控制修饰符"></a>1、访问控制修饰符</h3><p>访问控制修饰符分为四个级别：</p><ul><li><strong>公开级别</strong>：用<code>public</code>修饰，对外公开。</li><li><strong>受保护级别</strong>：用<code>protected</code>修饰，向子类以及同一个包中的类公开。</li><li><strong>默认级别</strong>：没有访问控制修饰符，向同一个包中的类公开。</li><li><strong>私有级别</strong>：用<code>private</code>修饰，只有类本身可以访问，不对外公开。</li></ul><table><thead><tr><th align="center">修饰符</th><th align="center">同一个类</th><th align="center">同一个包</th><th align="center">子类</th><th align="center">整体</th></tr></thead><tbody><tr><td align="center"><strong>private</strong></td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>default</strong></td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>protected</strong></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center"><strong>public</strong></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><blockquote><h5 id="关于protected修饰符的注意事项："><a href="#关于protected修饰符的注意事项：" class="headerlink" title="关于protected修饰符的注意事项："></a>关于protected修饰符的注意事项：</h5><ul><li>父类的<code>protected</code>成员<strong>是包内可见的，并且对子类可见。</strong></li><li>若子类和父类<strong>不在同一个包</strong>中，那么在子类中，<strong>子类实例可以访问其从父类继承而来的<code>protected</code>方法，而不能访问父类实例的<code>protected</code>方法</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//superClass:</span><br><span class="hljs-keyword">package</span> test_protected.superclass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-comment">//subClass:</span><br><span class="hljs-keyword">package</span> test_protected.subclass;<br><span class="hljs-keyword">import</span> test_protected.superclass.Father;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//子类实例访问从父类继承的protected属性和方法</span><br>        a = <span class="hljs-number">1</span>; <span class="hljs-comment">//正确</span><br>        test(); <span class="hljs-comment">//正确</span><br>        <span class="hljs-comment">//访问父类实例的protected属性和方法</span><br>        <span class="hljs-type">Father</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br>        f.a = <span class="hljs-number">1</span>; <span class="hljs-comment">//编译错误</span><br>        f.test(); <span class="hljs-comment">//编译错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于<code>protected</code>修饰的静态变量，<strong>无论是否同一个包，在子类中均可直接访问</strong>。</li><li>在不同包下，在子类中<strong>不能</strong>通过<strong>另一个子类引用</strong>访问<strong>共同基类的<code>protected</code>方法</strong>。</li></ul></blockquote><h3 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h3><p><strong>单例类</strong>指<strong>仅有一个实例</strong>的类。</p><blockquote><h5 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h5><ul><li>只需要使用一个单独的资源，并且需要共享这个单独资源的信息时，使用单例模式。</li><li>需要频繁的的进行创建和销毁对象。</li><li>创建对象时耗时过多或耗费资源过多，但又经常使用到的对象。</li><li>工具类对象。</li><li>频繁访问数据库或文件的对象。</li></ul></blockquote><h4 id="2-1、“饿汉式”单例模式"><a href="#2-1、“饿汉式”单例模式" class="headerlink" title="2.1、“饿汉式”单例模式"></a>2.1、“饿汉式”单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态的，保留自身的引用，类加载时就初始化。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">//必须是私有的构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">//公共的静态的方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h5 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h5><ul><li>没有Lazy初始化，但是具有多线程安全。</li><li>优点：没有加锁，执行效率会更高。</li><li>缺点：类加载时就初始化，容易产生垃圾，浪费内存。</li></ul></blockquote><h4 id="2-2、“懒汉式”单例模式"><a href="#2-2、“懒汉式”单例模式" class="headerlink" title="2.2、“懒汉式”单例模式"></a>2.2、“懒汉式”单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 静态的，保留自身的引用。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//必须是私有的构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">//公共的静态的方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h5 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h5><ul><li>进行 Lazy 初始化，但是多线程不安全。</li><li>若想要线程安全，需要加锁(<code>synchronized</code>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>)<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="四、继承-inheritance"><a href="#四、继承-inheritance" class="headerlink" title="四、继承(inheritance)"></a>四、继承(inheritance)</h2><p>继承是一种<code>is-a</code>的关系，但并不是所有<code>is-a</code>的关系都可以写成继承。</p><p>Java<strong>只允许单继承</strong>，不允许多继承。</p><blockquote><h5 id="子类-subClass-从父类-superClass-那里继承的东西"><a href="#子类-subClass-从父类-superClass-那里继承的东西" class="headerlink" title="子类(subClass)从父类(superClass)那里继承的东西"></a>子类(subClass)从父类(superClass)那里继承的东西</h5><ul><li>子类拥有父类的所有的属性和方法。</li><li>子类可以对父类进行扩展。子类可以拥有自己的属性和方法。子类既可以<strong>重载</strong>父类的方法，也可以<strong>覆盖/重写</strong>父类的方法。</li></ul><p>但子类<strong>不能继承父类的构造方法</strong>。</p></blockquote><p>类继承的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符] class 类名 extends 父类名&#123;<br>类体;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、子类构造函数"><a href="#1、子类构造函数" class="headerlink" title="1、子类构造函数"></a>1、子类构造函数</h3><p>由于父类的构造函数不能被继承，所以子类需要编写构造函数。</p><blockquote><ul><li><h5 id="无参子类构造函数"><a href="#无参子类构造函数" class="headerlink" title="无参子类构造函数"></a>无参子类构造函数</h5><ul><li>子类可以通过<code>super()</code>显式调用父类无参的构造函数，也可以隐式调用。</li></ul></li><li><h5 id="有参子类构造函数"><a href="#有参子类构造函数" class="headerlink" title="有参子类构造函数"></a>有参子类构造函数</h5><ul><li>需要初始化父类的成员变量。</li><li>需要初始化子类的成员变量。</li><li>必须显式调用父类有参构造函数。</li></ul></li></ul><h5 id="TIPS：无论使用this调用本类构造函数，还是使用super调用父类构造函数，都必须是该方法体中的第一条可执行语句，否则会产生语法错误。"><a href="#TIPS：无论使用this调用本类构造函数，还是使用super调用父类构造函数，都必须是该方法体中的第一条可执行语句，否则会产生语法错误。" class="headerlink" title="TIPS：无论使用this调用本类构造函数，还是使用super调用父类构造函数，都必须是该方法体中的第一条可执行语句，否则会产生语法错误。"></a>TIPS：无论使用<code>this</code>调用本类构造函数，还是使用<code>super</code>调用父类构造函数，都必须是该方法体中的第一条可执行语句，否则会产生语法错误。</h5></blockquote><ul><li><h4 id="子类对象的构建"><a href="#子类对象的构建" class="headerlink" title="子类对象的构建"></a>子类对象的构建</h4><ul><li>子类创建对象时，子类的构造方法总是先调用父类的某个构造方法，完成父类部分的创建；然后再调用子类自己的构造方法，完成子类部分的创建。</li><li>如果子类的构造方法没有显式指明调用了父类的哪一构造方法，子类就调用父类的不带参数的构造方法。</li><li>子类在创建一个子类对象时，不仅为子类中声明得成员变量都分配了内存，而且父类的所有的成员变量也都分配了内存空间。</li></ul></li><li><h4 id="this和super用法"><a href="#this和super用法" class="headerlink" title="this和super用法"></a><code>this</code>和<code>super</code>用法</h4><blockquote><ul><li><h5 id="this用于："><a href="#this用于：" class="headerlink" title="this用于："></a><code>this</code>用于：</h5><ul><li>引用自身对象的成员变量：<code>this.age</code></li><li>引用自身对象的成员方法：<code>this.display()</code></li><li>调用自身的构造方法：<code>this(&quot;Jack&quot;, &quot;male&quot;, 10)</code></li></ul></li><li><h5 id="super用于："><a href="#super用于：" class="headerlink" title="super用于："></a><code>super</code>用于：</h5><ul><li>引用父类对象的成员变量：<code>super.age</code></li><li>引用父类对象的成员方法：<code>super.display()</code></li><li>引用父类的构造方法：<code>super(&quot;Jack&quot;, &quot;male&quot;, 10)</code></li></ul></li></ul></blockquote></li></ul><h3 id="2、向上造型-upcasting"><a href="#2、向上造型-upcasting" class="headerlink" title="2、向上造型(upcasting)"></a>2、向上造型(upcasting)</h3><blockquote><p>详见多态</p></blockquote><h3 id="3、变量隐藏和方法覆盖"><a href="#3、变量隐藏和方法覆盖" class="headerlink" title="3、变量隐藏和方法覆盖"></a>3、变量隐藏和方法覆盖</h3><ul><li><h4 id="变量隐藏"><a href="#变量隐藏" class="headerlink" title="变量隐藏"></a>变量隐藏</h4><ul><li>在子类对父类的继承中，子类的成员变量和父类的成员变量同名，称此时子类<strong>隐藏</strong>(<code>override</code>)了父类的成员变量。</li><li>当发生变量隐藏后，子类若要引用父类的同名变量，要用<code>super</code>进行引用：<code>super.变量名</code>。</li></ul></li><li><h4 id="方法隐藏-方法覆盖"><a href="#方法隐藏-方法覆盖" class="headerlink" title="方法隐藏/方法覆盖"></a>方法隐藏/方法覆盖</h4><ul><li>方法覆盖就是子类的方法跟父类的方法具有完全一样的签名和参数（<strong>名称、参数、返回类型完全相同</strong>）。</li><li>方法覆盖在Java中属于动态联编（详见多态）。</li><li><strong>私有方法、静态方法不能被覆盖</strong>，如果在子类中出现了同签名的方法，称为<strong>方法隐藏</strong>。</li><li>用<code>final</code>声明的成员方法是<strong>最终方法</strong>，<strong>最终方法不能被子类覆盖（重写）</strong>。</li></ul></li></ul><h2 id="五、多态-polymorphism"><a href="#五、多态-polymorphism" class="headerlink" title="五、多态(polymorphism)"></a>五、多态(polymorphism)</h2><ul><li>多态有两种<ul><li><strong>静态多态性</strong>：包括方法的隐藏、方法的重载；在编译时决定调用哪个方法，即<strong>编译时的多态</strong>，也称为<strong>静态联编/静绑定</strong>。<ul><li><strong>Tips</strong>：静多态与是否发生继承<strong>没有</strong>必然联系。</li></ul></li><li><strong>动态多态性</strong>：在<strong>编译时不能确定要调用的方法</strong>，只有<strong>在运行时才能确定</strong>所要调用的方法。</li></ul></li></ul><h3 id="1、动多态"><a href="#1、动多态" class="headerlink" title="1、动多态"></a>1、动多态</h3><p>动态多态：在<strong>运行时</strong>确定调用的方法，也称为<strong>运行时多态、动态联编、动绑定</strong>。</p><ul><li>方法覆盖是指子类的成员方法重写了父类的成员方法，<strong>重写的目的很大程度上是为了实现多态</strong>。</li></ul><p><strong>Java 中，实现多态有3个条件：继承、覆盖、向上造型，缺一不可。</strong></p><blockquote><p>Java 形成动态多态必须具备的条件：</p><ul><li>必须要有<strong>继承</strong>的情况存在。</li><li>在继承中必须要有<strong>方法的覆盖</strong>。</li><li>必须<strong>由父类的引用指向派生类的实例</strong>，<strong>并且通过父类的引用调用被覆盖的方法</strong>。<ul><li>由父类的引用指向派生类的实例：<code>SuperClass superClass = new SubClass();</code></li><li>通过父类的引用调用被覆盖的方法：<code>superClass.f();</code></li></ul></li></ul><p>即<strong>继承是实现动多态的首要前提</strong>。</p></blockquote><h4 id="1-1、方法覆盖"><a href="#1-1、方法覆盖" class="headerlink" title="1.1、方法覆盖"></a>1.1、方法覆盖</h4><p>方法覆盖：要求方法名、参数个数、参数类型以及参数顺序必须一致。</p><p><strong>Tips：</strong>若父类方法定义时有异常抛出，则子类覆盖父类该方法时，该方法不能有更多的异常抛出，否则编译时会产生错误。</p><blockquote><h5 id="方法覆盖注意："><a href="#方法覆盖注意：" class="headerlink" title="方法覆盖注意："></a>方法覆盖注意：</h5><ul><li><p>子类方法<strong>不能缩小</strong>父类方法的<strong>访问权限</strong>。</p><ul><li><code>package</code>方法可以被写成<code>package</code>、<code>protected</code>、<code>public</code></li><li><code>protected</code>方法可以被写成<code>protected</code>、<code>public</code></li><li><code>public</code>方法只能被写成<code>public</code></li></ul><p><strong>PS：</strong>对于<strong>异常</strong>来说，<strong>不能扩大重写方法抛出的异常</strong>，这样会导致无法catch到。</p></li><li><p><strong>私有方法、静态方法</strong>不能被覆盖，如果在子类中出现了同签名的方法，就是方法隐藏。</p></li><li><p>父类中，<code>final</code>修饰的方法是最终方法，不允许覆盖。</p></li></ul></blockquote><h4 id="1-2、动多态注意事项"><a href="#1-2、动多态注意事项" class="headerlink" title="1.2、动多态注意事项"></a>1.2、动多态注意事项</h4><ul><li>子类的成员变量和父类同名，会出现<strong>变量隐藏</strong>的情况；子类“重写”父类的<code>private</code>或<code>static</code>函数，会出现<strong>函数隐藏</strong>的情况。<strong>用父类引用访问那个被隐藏的变量，只会访问父类的那个变量；用父类引用调用那个被隐藏的函数，只会调用父类的那个函数。</strong></li><li><strong>向上造型</strong>是通过父类的引用动态调用子类重写的方法，但是<strong>不能够访问子类新增的成员</strong>。此时可以通过<strong>强制转型（向下造型）</strong>来访问子类新增的成员，但<strong>具有一定的风险</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SuperClass::f()&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SubClass::f()&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">g</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SubClass::g()&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SuperClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br>        superClass.f(); <span class="hljs-comment">// 正确，输出 SubClass::f()</span><br>        superClass.g(); <span class="hljs-comment">// 错误</span><br>        <span class="hljs-type">SubClass</span> <span class="hljs-variable">subClass</span> <span class="hljs-operator">=</span> (SubClass) superClass;<br>        subClass.g(); <span class="hljs-comment">// 正确，但有⻛险，输出 SubClass::g()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、抽象-abstract"><a href="#六、抽象-abstract" class="headerlink" title="六、抽象(abstract)"></a>六、抽象(abstract)</h2><p>用关键字<code>abstract</code>修饰方法和类，表示抽象，有尚未实现的含义。</p><ul><li><p><strong>抽象类</strong>：用<code>abstract</code>修饰的类。</p><ul><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>普通的一个类，也可以用<code>abstract</code>修饰，但是没有实际意义。但是<strong>含有抽象函数的类必须用抽象类</strong>。</p></li></ul></li><li><p><strong>抽象方法</strong>：用<code>abstract</code>修饰的方法。抽象方法<strong>没有方法体</strong>（没有方法体和方法体为空是两个不同的概念），格式为</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符] <span class="hljs-keyword">abstract</span> [返回值类型] 方法名(参数列表);<br><span class="hljs-comment">//eg:public abstract void print(); -&gt; 没有方法体，即没有大括号</span><br></code></pre></td></tr></table></figure><blockquote><h5 id="几点注意："><a href="#几点注意：" class="headerlink" title="几点注意："></a>几点注意：</h5><ul><li>抽象函数没有函数体。</li><li>抽象函数必须在抽象类中。</li><li>抽象函数必须在子类中被实现，除非子类也是抽象类。</li></ul></blockquote><h3 id="关于抽象类和抽象方法更多的细节："><a href="#关于抽象类和抽象方法更多的细节：" class="headerlink" title="关于抽象类和抽象方法更多的细节："></a>关于抽象类和抽象方法更多的细节：</h3><ul><li>抽象类一般使用在<strong>父类对象没有机会被访问调用，或者父类的函数很难明确的实现</strong>的情况下，适合使用抽象类。</li><li><strong>不能实例化抽象类</strong>，但是，可以通过抽象类的引用管理其子类，实现动态联编。</li><li><strong>含有抽象函数的类必须是抽象类</strong>。<ul><li>如果一个子类继承自某个抽象类，但是<strong>没有实现或者只实现了部分父类中的抽象函数</strong>，那么<strong>子类必须声明为抽象类</strong>。</li><li>当一个类声明实现了某个接口，但是<strong>没有实现或者只实现了该接口的部分的函数</strong>，则<strong>这个类必须声明为抽象类</strong>。</li><li><strong>一个抽象类中可以声明成员变量和函数</strong>，包括静态的类变量和类函数。</li></ul></li></ul><h2 id="七、接口-interface"><a href="#七、接口-interface" class="headerlink" title="七、接口(interface)"></a>七、接口(interface)</h2><p>接口是一种<strong>特殊的抽象类</strong>，在这个抽象类中，只<strong>包含常量和方法的定义</strong>，而<strong>没有方法的实现</strong>。即可以说：接口时抽象方法和常量值的定义的集合。</p><p>从语法上来看，接口与“类”很相似，只是<strong>接口中所有的方法都是抽象的</strong>。</p><blockquote><h5 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h5><ul><li>接口中所有的方法都默认是<code>public abstract</code>的，并且只有方法头和参数列表，没有方法体。</li><li>接口中所有的变量都默认是<code>public static final</code>的。</li><li>接口中没有构造方法。</li><li>一个类可以实现多个接口。（即 Java 通过这种方式来实现多继承）</li><li>用其他语言<code>(C, Python.etc)</code>书写接口时，接口方法需要用<code>native</code>关键字修饰。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口的定义和声明</span><br>[<span class="hljs-keyword">public</span>][interface]InterfaceName[<span class="hljs-keyword">extends</span> <span class="hljs-title class_">superInterfaces</span>]&#123;<br>    <span class="hljs-comment">//静态常量</span><br>    [<span class="hljs-keyword">public</span>][<span class="hljs-keyword">static</span>][<span class="hljs-keyword">final</span>]数据类型 变量名 = 常量名;<br>    <span class="hljs-comment">//抽象方法</span><br>    [<span class="hljs-keyword">public</span>][<span class="hljs-keyword">abstract</span>][<span class="hljs-keyword">native</span>]返回值类型 方法名（参数列表）;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现接口</span><br>[修饰符]<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>[<span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClassName</span>][implements 接口A, 接口B..]&#123;<br>    <span class="hljs-comment">//body</span><br>    <span class="hljs-comment">//类中的成员变量和成员方法</span><br>    <span class="hljs-comment">//为接口A中的所有方法编写方法体，实现接口A</span><br>    <span class="hljs-comment">//为接口B中的所有方法编写方法体，实现接口B</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h5><ul><li>一个类在实现接口的函数时，应采用完全相同的函数头，否则就只是重载一个新方法，而不是实现接口中的抽象方法。</li><li>接口的抽象函数访问权限是<code>public</code>，因此类在实现时，必须<strong>显式的使用</strong><code>public</code>修饰符，否则将被警告为缩小了接口中定义的方法的访问控制范围。</li></ul></blockquote><h3 id="1、接口的回调"><a href="#1、接口的回调" class="headerlink" title="1、接口的回调"></a>1、接口的回调</h3><p>接口回调：把实现某一接口的类创建的对象引用赋给该接口声明的接口变量该接口变量就可以调用被实现的接口中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">接口变量 = 实现该接口的类所创建的对象;<br>接口变量.接口方法([参数列表]);<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MyInterface.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MyClass.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//body</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br> <span class="hljs-type">MyInterface</span> <span class="hljs-variable">myInterface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>  myInterface.f();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>Tips:</strong></p><ul><li><strong>用一个接口类型的引用去管理实现了该接口的类的实例化对象，那么就可以通过这个引用去调用接口中的那些函数。</strong></li><li>接口也可以作为<strong>函数的参数（函数传参）[声明时]</strong>，但<strong>实际传入的参数[调用时]</strong>是<strong>实现了该接口的类的对象的引用</strong>，那么<strong>接口参数就可以回调类实现的接口方法</strong>。</li></ul><h3 id="2、接口的继承"><a href="#2、接口的继承" class="headerlink" title="2、接口的继承"></a>2、接口的继承</h3><ul><li><p>接口可以像普通的类一样用关键词<code>extends</code>继承父接口，从而得到父接口中所有的成员。</p></li><li><p>接口中的函数在某一个实现该接口的类中，只能被书写一次。</p></li><li><p>不同接口（包括父子接口）中同名的变量相互隐藏，使用时应用<code>接口名.变量名</code>的形式明确指出。</p><ul><li><h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//In.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">In</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">In</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(a); <span class="hljs-comment">// 1</span><br>        System.out.println(In.a); <span class="hljs-comment">// 1</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>().b); <span class="hljs-comment">// 22</span><br>        System.out.println(In.b); <span class="hljs-comment">// 2</span><br>        System.out.println(c); <span class="hljs-comment">// 33</span><br>        System.out.println(In.c); <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//In1.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">In1</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//In2.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">In2</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">In1</span>, In2 &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(a); <span class="hljs-comment">//错误，存在冲突</span><br>        System.out.println(In1.a); <span class="hljs-comment">// 1</span><br>        System.out.println(In2.a); <span class="hljs-comment">// 2</span><br>        <br>        System.out.println(b); <span class="hljs-comment">// 99</span><br>        System.out.println(In1.b); <span class="hljs-comment">// 11</span><br>        System.out.println(In2.b); <span class="hljs-comment">// 22</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、instanceof"><a href="#3、instanceof" class="headerlink" title="3、instanceof"></a>3、<code>instanceof</code></h3><ul><li><p><strong>向上造型总是安全的。</strong>通过向上造型可以实现动多态，但是<strong>不能通过父类的引用访问子类新增的成员变量</strong>。</p></li><li><p><strong>向下造型是有风险的。</strong>如果不能进行转型，则会报出<strong>运行时错误</strong>，编译时无法确定。但向下造型的好处在于可以使用子类特有的功能。</p></li><li><p><code>instanceof</code>是一个<strong>二元运算符</strong>，用于判断一个引用类型所管理的对象是不是一个类的实例。左侧算子是一个<strong>引用类型的变量</strong>（可以是<code>null</code>），右侧的算子是一个<strong>类名或者接口名</strong>。运算符的结果是<code>boolean</code>类型的<code>true</code>或者<code>false</code>。</p></li><li><p><strong><code>instanceof</code>细节</strong></p><ul><li><p>表达式<code>A instanceof B</code>的值为<code>true</code>的情况包括</p><ul><li>引用<code>A</code>管理类<code>B</code>的对象</li><li><code>B</code>为<code>A</code>的直接或间接父类</li><li><code>B</code>为<code>A</code>实现的接口</li></ul></li><li><p><strong>强制转型</strong>，可能会发生<strong>编译错误</strong>，也有可能会<strong>抛出<code>ClassCastException</code></strong>。</p><ul><li><p>编译错误发生的情形</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 毫无关系的类之间进行强制转型。</span><br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)random;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用接口管理未实现该接口的final类</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> (list)integer;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用一个final类管理其未实现的接口</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)list;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>抛出<code>ClassCastException</code>的情形</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用子类管理父类（即使子类是final）</span><br>Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Integer&gt;();<br>Stack&lt;Integer&gt; stack = (Stack&lt;Integer&gt;)vector;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用接口管理未实现该接口的普通类</span><br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> (list)random;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用未实现某个接口的普通类管理该接口</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> (Random)list;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用一个接口管理另一个接口</span><br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> (Runnable)list;<br></code></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>当强制转换不能通过编译时，<code>instanceof</code>也不能通过编译；当强制转换会抛出异常时，<code>instanceof</code>返回<code>false</code>。如果<code>instanceof</code>左侧算子不为<code>null</code>，并且强制转换不抛出<code>ClassCastException</code>。</p></li></ul></li></ul><h2 id="八、Java集合框架"><a href="#八、Java集合框架" class="headerlink" title="八、Java集合框架"></a>八、Java集合框架</h2><blockquote><ul><li><code>Collection</code>接口存储一组<strong>不唯一，无序</strong>的对象。</li><li><code>List</code>接口存储一组<strong>不唯一，有序（插入顺序）</strong>的对象。</li><li><code>Set</code>接口存储一组<strong>唯一，无序</strong>的对象。</li><li><code>Map</code>接口存储一组<strong>键值</strong>对象，提供<code>key</code>到<code>value</code>的映射。</li></ul></blockquote><p>Java 所有的集合类都位于<code>java.util</code>包下。Java 的集合类主要由两个接口派生而出：<code>Collection</code>和<code>Map</code>，<code>Collection</code>和<code>Map</code>是 Java 集合框架的根接口，这两个接口又包含了一些子接口或实现类。</p><ul><li>关于集合框架总体的一些说明<ul><li><code>Collection</code>接口是一组允许重复的对象。</li><li><code>Set</code>接口继承<code>Collection</code>，集合元素不重复。</li><li><code>List</code>接口继承<code>Collection</code>，允许重复，维护元素的插入顺序。</li><li><code>Map</code>接口时键值对象，与<code>Collection</code>接口没有什么关系。</li><li><code>Set</code>，<code>List</code>，<code>Map</code>可以看做集合的三大类：<ul><li><code>List</code>集合是有序集合，<strong>集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</strong></li><li><code>Set</code>集合是无序集合，<strong>集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。</strong></li><li><code>Map</code>集合中保存<code>Key-Vaule</code>对形式的元素，访问时只能根据每项元素的<code>key</code>来访问其<code>value</code>。</li></ul></li></ul></li></ul><h3 id="1、Set接口实现类"><a href="#1、Set接口实现类" class="headerlink" title="1、Set接口实现类"></a>1、<code>Set</code>接口实现类</h3><p><code>Set</code>中的元素必须唯一，并且添加到<code>Set</code>中的元素必须定义<code>equal</code>方法，从而保证建立对象的唯一性。</p><p>实现<code>Set</code>接口的类有<code>HashSet</code>，<code>TreeSet</code>。</p><p>简单举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        HashSet&lt;String&gt; h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br>        h.add(<span class="hljs-string">&quot;one&quot;</span>);<br>        h.add(<span class="hljs-string">&quot;two&quot;</span>);<br>        h.add(<span class="hljs-string">&quot;three&quot;</span>);<br>        h.add(<span class="hljs-string">&quot;one&quot;</span>);<br>        Iterator&lt;String&gt; it = h.iterator;<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">print:</span><br><span class="hljs-comment">one</span><br><span class="hljs-comment">two</span><br><span class="hljs-comment">three</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><h3 id="2、List接口实现类"><a href="#2、List接口实现类" class="headerlink" title="2、List接口实现类"></a>2、<code>List</code>接口实现类</h3><p><code>List</code>的明显特征就是<strong>它的元素都有一个确定的顺序</strong>。</p><p>实现它的类有<code>ArrayList</code>和<code>LinkedList</code></p><ul><li><strong><code>ArrayList</code></strong>：在内存中是顺序存储的。<code>ArrayList</code>实现了长度可变的数组，在内存中分配连续的空间。<strong>遍历元素和随即访问元素的效率较高</strong>。</li><li><strong><code>LinkedList</code></strong>：在内存中是以链表方式存储的。<strong>插入，删除元素的效率比较高</strong>。</li></ul><h3 id="3、Map接口实现类"><a href="#3、Map接口实现类" class="headerlink" title="3、Map接口实现类"></a>3、<code>Map</code>接口实现类</h3><p><code>Map</code>接口专门处理键值映射数据的存储，可以根据键实现对值的操作。</p><p>常用的实现类是<code>HashMap</code>和<code>TreeMap</code>。</p><h3 id="4、集合类的对比"><a href="#4、集合类的对比" class="headerlink" title="4、集合类的对比"></a>4、集合类的对比</h3><ul><li><code>Vector</code>和<code>ArrayList</code>的异同<ul><li>它们的实现原理相同，功能相同，很多情况下可以互用。</li><li>两者的主要区别是<ul><li><strong><code>Vector</code>线程安全，ArrayList重速度轻安全，线程非安全。</strong></li><li>长度增长时，<code>Vector</code>默认增长一倍，<code>ArrayList</code>默认增长50%。</li></ul></li></ul></li><li><code>Hashtable</code>和<code>HashMap</code>的异同<ul><li>它们的实现原理相同，功能相同，很多情况下可以互用。</li><li>两者的主要区别是<ul><li>Hashtable继承<code>Dictionary</code>类，HashMap实现Map接口。</li><li><strong><code>Hashtable</code>线程安全，<code>HashMap</code>线程不安全。</strong></li><li><strong><code>Hashtable</code>不允许<code>null</code>值，<code>HashMap</code>允许<code>null</code>值。</strong></li></ul></li></ul></li></ul><h3 id="5、Iterator接口"><a href="#5、Iterator接口" class="headerlink" title="5、Iterator接口"></a>5、<code>Iterator</code>接口</h3><p>利用<code>Iterator</code>接口实现一个迭代器，来实现对集合的遍历，因为所有的集合接口和类都没有提供相应的遍历方法，而是由<code>Iterator</code>实现集合遍历。</p><p><code>Collection</code>接口的<code>iterate()</code>方法返回一个<code>Iterator</code>，然后通过<code>Iterate</code>接口的两个方法可以实现遍历</p><ul><li><code>boolean hasNext()</code>：判断是否存在另一个可访问的元素。</li><li><code>Object next()</code>：返回要访问的下一个元素。</li></ul><p><strong>Tips</strong>：<code>Iterator</code>仅用于遍历集合，<code>Iterator</code>本身并不提供承装对象的能力。如果需要创建<code>Iterator</code>对象，则必须有一个被迭代的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 迭代器遍历ArrayList示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 迭代器遍历Map示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            map.put(i, i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> map.entrySet().iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) it.next();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (Integer) entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (Integer) entry.getValue();<br>            System.out.println(key + <span class="hljs-string">&quot; : &quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="九、完善类的设计"><a href="#九、完善类的设计" class="headerlink" title="九、完善类的设计"></a>九、完善类的设计</h2><h3 id="（一）面向对象的几个基本原则"><a href="#（一）面向对象的几个基本原则" class="headerlink" title="（一）面向对象的几个基本原则"></a>（一）面向对象的几个基本原则</h3><h4 id="1、类的UML图"><a href="#1、类的UML图" class="headerlink" title="1、类的UML图"></a>1、类的UML图</h4><p><strong>UML（Unified Modeling Language）统一建模语言，又称标准建模语言，是用来对软件密集系统进行可视化建模的一种语言</strong></p><h4 id="2、面向接口的编程（面向抽象原则）"><a href="#2、面向接口的编程（面向抽象原则）" class="headerlink" title="2、面向接口的编程（面向抽象原则）"></a>2、面向接口的编程（面向抽象原则）</h4><h3 id="（二）设计模式"><a href="#（二）设计模式" class="headerlink" title="（二）设计模式"></a>（二）设计模式</h3><p><strong>设计模式是针对某一类问题的最佳解决方案</strong>。应当基于业务来选择设计模式。</p><blockquote><h5 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h5><ul><li><p><strong>创建型设计模式</strong></p><p>创建型设计模式设计对象的实例化，这类模式的特点是：不让用户代码依赖于对象的创建或排列方式，避免用户直接使用<code>new</code>运算符创建对象。</p><ul><li><p><strong>单例（Singleton）模式</strong></p><p>某个类<strong>只能生成一个实例</strong>，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p></li><li><p><strong>原型（Prototype）模式</strong></p><p>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p></li><li><p><strong>工厂方法（FactoryMethod）模式</strong></p><p>定义一个用于创建产品的接口，由子类决定生产什么产品。</p></li><li><p><strong>抽象工厂（AbstractFactory）模式</strong></p><p>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p></li><li><p><strong>建造者（Builder）模式</strong></p><p>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建他们，最后构建成该复杂对象。</p></li></ul></li><li><p><strong>结构型设计模式</strong></p><p>结构型设计模式涉及怎样合理的设计对象之间的交互通信，以及怎样合理为对象分配职责，让设计富有弹性，易维护，易复用。</p><ul><li><p><strong>代理（Proxy）模式</strong></p><p>为某对象提供一种代理以控制该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p></li><li><p><strong>适配器（Adapter）模式</strong></p><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p></li><li><p><strong>桥接（Bridge）模式</strong></p><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</p></li><li><p><strong>装饰（Decorator）模式</strong></p><p>动态地给对象增加一些职责，即增加其额外的功能。</p></li><li><p><strong>外观（Facade）模式</strong></p><p>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p></li><li><p><strong>享元（Flyweight）模式</strong></p><p>运用共享技术来有效地支持大量细粒度对象的复用。</p></li><li><p><strong>组合（Composite）模式</strong></p><p>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p></li></ul></li><li><p><strong>行为型设计模式</strong></p><p>行为型设计模式涉及如何组合类和对象以形成更大的结构，和类有关的结构型模式涉及如何合理地使用继承机制，和对象有关的结构型模式涉及如何合理地使用对象组合机制。</p><ul><li><p><strong>模板方法（Template Method）模式</strong></p><p>定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类可以再不改变该算法结构的情况下重定义该算法的某些特定步骤。</p></li><li><p><strong>策略（Strategy）模式</strong></p><p>定义一系列算法，并将每个算法都封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p></li><li><p><strong>命令（Command）模式</strong></p><p>把一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。</p></li><li><p><strong>职责链（Chain of Responsibility）模式</strong></p><p>把请求从链中的一个对象传到下一个对象，知道请求被响应为止。通过这种方式去除对象之间的耦合。</p></li><li><p><strong>状态（State）模式</strong></p><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p></li><li><p><strong>观察者（Observer）模式</strong></p><p>多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p></li><li><p><strong>中介者（Mediator）模式</strong></p><p>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</p></li><li><p><strong>迭代器（Iterator）模式</strong></p><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p></li><li><p><strong>访问者（Vistor）模式</strong></p><p>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式,，即每个元素有多个访问者对象访问。</p></li><li><p><strong>备忘录（Memento）模式</strong></p><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p></li><li><p><strong>解释器（Interpreter）模式</strong></p><p>提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p></li></ul></li></ul></blockquote><h4 id="1、策略模式"><a href="#1、策略模式" class="headerlink" title="1、策略模式"></a>1、策略模式</h4><p>当程序的主要类（相当于上下文角色）不希望暴露复杂的、与算法相关的数据结构，可以使用策略模式来封装算法，即将算法分别封装到具体策略中。</p><blockquote><h5 id="策略模式的结构"><a href="#策略模式的结构" class="headerlink" title="策略模式的结构"></a>策略模式的结构</h5><ul><li><p><strong>策略</strong></p><p>核心是将类中经常变化的部分分割出来，并将每种可能的变化对应的交给抽象类的一个子类或实现接口的一个类去负责。</p><p><strong>好处在于</strong>类的设计者不用关心具体实现，避免所设计的类过度依赖具体的实现。</p></li><li><p><strong>上下文（Context）</strong></p><p>上下文面向策略，即是面向接口<code>Strategy</code>的类。</p></li><li><p><strong>具体策略</strong></p><p>具体策略是实现<code>Strategy</code>接口的类，即必须重写接口中的方法。</p></li></ul></blockquote><blockquote><h5 id="举例：多个裁判给选手打分，用多种方法计算选手的得分情况。"><a href="#举例：多个裁判给选手打分，用多种方法计算选手的得分情况。" class="headerlink" title="举例：多个裁判给选手打分，用多种方法计算选手的得分情况。"></a>举例：多个裁判给选手打分，用多种方法计算选手的得分情况。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 策略接口命名为Strategy</span><br><span class="hljs-comment">// Strategy.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br><span class="hljs-type">double</span> <span class="hljs-title function_">calcScore</span><span class="hljs-params">(<span class="hljs-type">double</span>[] scores)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文</span><br><span class="hljs-comment">// AverageScore.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AverageScore</span> &#123;<br><span class="hljs-keyword">private</span> Strategy s;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(Strategy s)</span> &#123; <span class="hljs-built_in">this</span>.s = s; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">(<span class="hljs-type">double</span>[] scores)</span> &#123;<br>  <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s.calcScore(scores);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体策略 策略A</span><br><span class="hljs-comment">// StrategyA.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcScore</span><span class="hljs-params">(<span class="hljs-type">double</span>[] scores)</span> &#123;<br>  <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> score : scores) sum += score;<br>  <span class="hljs-keyword">return</span> sum / scores.length;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体策略 策略B</span><br><span class="hljs-comment">// StrategyB.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcScore</span><span class="hljs-params">(<span class="hljs-type">double</span>[] scores)</span> &#123;<br>  <span class="hljs-keyword">if</span> (scores.length &lt;= <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyA</span>().calcScore(scores);<br>  &#125;<br>  <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  Arrays.sort(scores); <span class="hljs-comment">// 去掉一个最高分，去掉一个最低分</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; scores.length - <span class="hljs-number">1</span>; i++) &#123;<br>      sum += scores[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum / (scores.length - <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">double</span>[] scores = &#123;<span class="hljs-number">90</span>, <span class="hljs-number">92</span>, <span class="hljs-number">94</span>, <span class="hljs-number">96</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>&#125;;<br>  <span class="hljs-type">AverageScore</span> <span class="hljs-variable">as</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AverageScore</span>();<br>  as.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyA</span>());<br>  System.out.println(as.getScore(scores));<br>  as.setStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyB</span>());<br>  System.out.println(as.getScore(scores));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>策略模式的优点</strong></p><ul><li>上下文和具体策略是松耦合关系。</li><li>策略模式满足”开-闭原则“。</li></ul><h4 id="2、访问者模式"><a href="#2、访问者模式" class="headerlink" title="2、访问者模式"></a>2、访问者模式</h4><p>当需要对集合中的对象进行很多不同且不相关的操作，同时我们又不希望修改对象的类，此时就可以使用访问者模式。访问者模式可以在<code>Visitor</code>类中集中定义一些关于集合中对象的操作。</p><blockquote><h5 id="访问者模式模式结构包含的四个角色"><a href="#访问者模式模式结构包含的四个角色" class="headerlink" title="访问者模式模式结构包含的四个角色"></a>访问者模式模式结构包含的四个角色</h5><ul><li><p><strong>抽象元素（Element）</strong></p><p>被访问的元素，一个抽象类，该类定义了接受访问者的accept操作。访问者需要访问元素，<strong>元素必须提供允许访问这访问它的方法。</strong></p></li><li><p><strong>具体元素（Concrete Element）</strong></p><p>被访问的元素，Element的子类。</p></li><li><p><strong>抽象访问者（Visitor）：规定访问时的操作</strong></p><p>一个接口，该接口定义操作具体元素的方法。在某些设计中，可能需要定义作用域类中的数据的新操作，而且这些新操作不应当由该类中的某个实例方法来承担时，将该方法定义于抽象访问者中。</p></li><li><p><strong>具体访问者（Concrete Visitor）：规定访问时的操作</strong></p><p>实现Vistor接口的类。</p></li></ul></blockquote><blockquote><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>根据电表显示的用电量计算用户的电费。用户包括居民和企业，访问同一个电表，及分别按家用电标准和工业用电标准计算了电费（家用：6000 度以下 0.6 元/度，以上 1.05 元/度；企业：15000 度以下 1.52 元/度；以上 2.78 元/度）。</p><p><strong>PS：</strong>电表有自己显示用电量的方法，但需要定义一个方法来计算电费，即需要定义一个作用于电量的新操作，但显然这个新的操作不应当由电表来承担。应当由记表员来观察电表的用电量，然后按照有关收费标准计算出电费，即让一个称作访问者的对象来访问电表。</p><ul><li>抽象访问者</li><li>具体访问者：居民和企业用户</li><li>抽象元素：抽象类：<code>Element</code></li><li>具体元素：模拟电表：<code>Ammeter</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象访问者</span><br><span class="hljs-comment">// Vistor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">HOME_STANDARD_ACCOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6000</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">HOME_LEVEL_LOW</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.6</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">HOME_LEVEL_HIGH</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.05</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">INDUSTRY_STANDARD_ACCOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">15000</span>;<br>    <span class="hljs-type">double</span>  <span class="hljs-variable">INDUSTRY_LEVEL_LOW</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.52</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">INDUSTRY_LEVEL_HIGH</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.78</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Element e)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体访问者1：居民</span><br><span class="hljs-comment">// HomeVisitor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Element e)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">fee</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> e.displayAmount();<br>        <span class="hljs-keyword">if</span> (amount &lt;= HOME_STANDARD_ACCOUNT)<br>            fee = amount * HOME_LEVEL_LOW;<br>        <span class="hljs-keyword">else</span><br>            fee = HOME_STANDARD_ACCOUNT * HOME_LEVEL_LOW + (amount - HOME_STANDARD_ACCOUNT) * HOME_LEVEL_HIGH;<br>        <span class="hljs-keyword">return</span> fee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体访问者2：企业用户</span><br><span class="hljs-comment">// IndustryVisitor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndustryVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Element e)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">fee</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> e.displayAmount();<br>        <span class="hljs-keyword">if</span> (amount &lt;= INDUSTRY_STANDARD_ACCOUNT)<br>            fee = amount * INDUSTRY_LEVEL_LOW;<br>        <span class="hljs-keyword">else</span><br>            fee = INDUSTRY_STANDARD_ACCOUNT * INDUSTRY_LEVEL_LOW + (amount - INDUSTRY_STANDARD_ACCOUNT) * INDUSTRY_LEVEL_HIGH;<br>        <span class="hljs-keyword">return</span> fee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象元素</span><br><span class="hljs-comment">// Element.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor v)</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">displayAmount</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAmount</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体元素</span><br><span class="hljs-comment">// Ammeter.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ammeter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amount;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor v)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">fee</span> <span class="hljs-operator">=</span> v.visit(<span class="hljs-built_in">this</span>);<br>        System.out.printf(<span class="hljs-string">&quot;The fee is %.2f\n&quot;</span>, fee);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAmount</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">displayAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Ammeter</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ammeter</span>();<br>        a.setAmount(<span class="hljs-number">8000</span>);<br>        <span class="hljs-type">Visitor</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HomeVisitor</span>();<br>        a.accept(v);<br>        v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndustryVisitor</span>();<br>        a.accept(v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="3、工厂模式"><a href="#3、工厂模式" class="headerlink" title="3、工厂模式"></a>3、工厂模式</h4><p><strong>工厂模式</strong>是定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中，具有<strong>创建型模式</strong>中要求的”<strong>创建与使用分离</strong>“的特点。</p><ul><li><p><strong>简单工厂</strong>：为产品创建工厂类，客户调用工厂的方法来获得产品。</p><blockquote><p>例：模拟生产中性笔，传入参数Red或red生产红笔，传入参数Black或black生产黑笔。其他颜色中性笔暂不生产。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Pen.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pen</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenFactory.java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedPen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pen</span> &#123;<br>RedPen() &#123;create();&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;Create a RedPen.&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackPen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pen</span> &#123;<br>BlackPen() &#123;create();&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;Create a BlackPen.&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenFactory</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pen <span class="hljs-title function_">create</span><span class="hljs-params">(String color)</span> &#123;<br>  <span class="hljs-keyword">if</span> (color.equalsIgnoreCase(<span class="hljs-string">&quot;Red&quot;</span>))<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedPen</span>();<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color.equalsIgnoreCase(<span class="hljs-string">&quot;Black&quot;</span>))<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackPen</span>();<br>  <span class="hljs-keyword">else</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Can&#x27;t create &quot;</span> + color + <span class="hljs-string">&quot; pen.&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenTest.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">Pen</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> PenFactory.create(<span class="hljs-string">&quot;Red&quot;</span>);<br>  <span class="hljs-type">Pen</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> PenFactory.create(<span class="hljs-string">&quot;Black&quot;</span>);<br>  <span class="hljs-type">Pen</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> PenFactory.create(<span class="hljs-string">&quot;Blue&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>工厂方法</strong></p><blockquote><p>此模式具有四种角色</p><ul><li>抽象产品</li><li>具体产品</li><li>抽象生产者</li><li>具体生产者</li></ul></blockquote><blockquote><p>例：模拟生产中性笔，红色和黑色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenCore.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenCore</span> &#123;<br><span class="hljs-keyword">protected</span> String color;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeDown</span><span class="hljs-params">(String s)</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;Write the word :\&quot;&quot;</span> + s + <span class="hljs-string">&quot;\&quot; in &quot;</span> + color + <span class="hljs-string">&quot; color.&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackPenCore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PenCore</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BlackPenCore</span><span class="hljs-params">()</span> &#123;<br>  color = <span class="hljs-string">&quot;Black&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedPenCore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PenCore</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RedPenCore</span><span class="hljs-params">()</span> &#123;<br>  color = <span class="hljs-string">&quot;Red&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenFactory.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenFactory</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> PenCore <span class="hljs-title function_">getPenCore</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackPenCoreCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PenFactory</span> &#123;<br><span class="hljs-keyword">public</span> PenCore <span class="hljs-title function_">getPenCore</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackPenCore</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedPenCoreCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PenFactory</span> &#123;<br><span class="hljs-keyword">public</span> PenCore <span class="hljs-title function_">getPenCore</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedPenCore</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PenCoreTest.java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BallPen</span> &#123;<br>PenCore pc;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPenCore</span><span class="hljs-params">(PenCore pc)</span> &#123;<br>  <span class="hljs-built_in">this</span>.pc = pc;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String s)</span> &#123;<br>  pc.writeDown(s);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PenCoreTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  PenFactory pf;<br>  <span class="hljs-type">BallPen</span> <span class="hljs-variable">bp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BallPen</span>();<br>  pf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackPenCoreCreator</span>();<br>  bp.setPenCore(pf.getPenCore());<br>  bp.write(<span class="hljs-string">&quot;Java&quot;</span>);<br>  pf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedPenCoreCreator</span>();<br>  bp.setPenCore(pf.getPenCore());<br>  bp.write(<span class="hljs-string">&quot;Linux&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="十、异常处理"><a href="#十、异常处理" class="headerlink" title="十、异常处理"></a>十、异常处理</h2><p>在编程时，通常会遇到三类错误：</p><ul><li><strong>编译错误（CE）</strong></li><li><strong>逻辑错误</strong></li><li><strong>运行时错误（RE）：在程序运行的过程中，如果发生了不可能执行的操作，就会出现运行时错误。</strong></li></ul><p><strong>异常</strong>是一个可以正确运行的程序，在运行的过程中可能发生的错误。编译系统检查出来的语法错误、导致程序运行结果不正确的逻辑错误，都不属于异常的范围。</p><p>异常实际是程序中错误导致中断了正常的指令流的一种事件。</p><h3 id="1、异常类的结构"><a href="#1、异常类的结构" class="headerlink" title="1、异常类的结构"></a>1、异常类的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java/%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B.png" alt="异常类型"></p><ul><li><code>Throwable</code>是所有异常类的父类，他是</li><li><strong><code>Object</code>的直接子类。</strong>是类库<code>java.lang</code>包的一个类。</li><li><strong><code>Exception</code>类继承自Throwable类。</strong>所有的<code>Throwable</code>类的子孙类所产生的对象都是例外。</li><li><code>Error</code>：由Java虚拟机生成并抛出，Java程序不做处理。</li><li><code>Runtime Exception</code>：由系统检测，用户的Java程序可以不做处理，系统将其交给缺省的异常处理程序。</li><li><strong><code>非Runtime Exception</code>：Java编译器要求Java程序必须捕捉或声明所有的非运行时异常。</strong></li><li><code>throw</code>：用户自己产生异常。</li></ul><h3 id="2、异常分类"><a href="#2、异常分类" class="headerlink" title="2、异常分类"></a>2、异常分类</h3><h4 id="按编译时是否受检来分"><a href="#按编译时是否受检来分" class="headerlink" title="按编译时是否受检来分"></a>按编译时是否受检来分</h4><ul><li><p><strong>非受检异常</strong>：包括<code>Runtime Exception</code>及其子类，<code>Error</code>及其子类。编译器对非受检异常类不进行检查。</p><blockquote><p><strong>非受检异常只能在程序执行时被检测到，而不能在编译时被检测到。</strong></p></blockquote></li><li><p><strong>受检异常</strong>：除了非受检异常意外其他的异常（即其他的异常类则是可检测的类）。</p><blockquote><ul><li>这些异常在编译时就能被Java编译器所检测到。</li><li><strong>必须采用声明异常或者<code>try-catch</code>方式处理异常。</strong></li></ul></blockquote></li></ul><h3 id="3、Java异常处理机制"><a href="#3、Java异常处理机制" class="headerlink" title="3、Java异常处理机制"></a>3、Java异常处理机制</h3><blockquote><h5 id="Java异常处理：抓抛模型"><a href="#Java异常处理：抓抛模型" class="headerlink" title="Java异常处理：抓抛模型"></a>Java异常处理：抓抛模型</h5><p>如果一个方法内抛出异常，该异常会被抛到调用方法中，如果一场没有在调用方法中处理，它继续被抛给这个调用方法的调用者。这个过程将一直继续下去，直到一场被处理，这一过程被称为：捕获异常（catch）。</p><p>如果一个异常回到<code>main()</code>方法，并且<code>main()</code>也不处理，则程序运行终止。</p></blockquote><h3 id="4、try-catch-finally处理异常"><a href="#4、try-catch-finally处理异常" class="headerlink" title="4、try...catch...finally处理异常"></a>4、<code>try...catch...finally</code>处理异常</h3><p><strong>捕获异常并处理异常</strong></p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">// 接受监视的程序块，在此区域内发生的异常，由catch中指定的程序处理</span><br>    &#125; <span class="hljs-keyword">catch</span> (ExceptionType e) &#123;<br>        <span class="hljs-comment">// 抛出ExceptionType异常时要执行的代码</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 无条件执行的语句</span><br>        <span class="hljs-comment">// 一般用于释放资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同一段程序可能产生不止一种异常，用多个<code>catch</code>子句来检查每一种异常类型，第一个与异常匹配的<code>catch</code>将会被执行。</li><li>如果<strong>一个异常类和这个异常类的子类都出现在<code>catch</code>中</strong>，应该<strong>把子类放在前面</strong>，否则将永远不会到达子类。</li><li><code>finally</code>：<strong>无条件执行语句，一般用于释放资源。</strong>即使没有<code>catch</code>语句，<code>finally</code>语句块也会在执行了<code>try</code>语句块之后立即执行。（比如在<code>try</code>中进行文件操作，使用了文件流，因此需要在<code>finally</code>中关闭文件流）</li></ul><h3 id="5、Throws语句声明异常"><a href="#5、Throws语句声明异常" class="headerlink" title="5、Throws语句声明异常"></a>5、<code>Throws</code>语句声明异常</h3><p><strong>声明异常：</strong>一个方法不处理它产生的异常，而是沿着调用层次向上传递，由调用它的方法来处理这些异常，叫声明异常。</p><p><code>Throws</code>语句用来表明一个方法可能抛出的各种异常，并说明该方法会抛出但不会捕获异常。</p><p>声明异常的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[访问权限修饰符][返回值类型][方法名](参数列表) <span class="hljs-keyword">throws</span> 异常列表 &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>一定是由调用方法处理该异常，如果最终方法也没有处理异常，异常将交给系统处理。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExceptionType &#123;<br>        <span class="hljs-comment">// do something</span><br>        <span class="hljs-comment">// 抛出了ExceptionType类型的异常</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f();<br>        &#125; <span class="hljs-keyword">catch</span> (ExceptionType e) &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p><strong>重写方法不能抛出比被重写方法范围更大的异常类型。</strong></p><h3 id="6、人工抛出异常：创建用户自定义的异常"><a href="#6、人工抛出异常：创建用户自定义的异常" class="headerlink" title="6、人工抛出异常：创建用户自定义的异常"></a>6、人工抛出异常：创建用户自定义的异常</h3><p>Java自定义异常不是由Java系统检测到的异常，而是由用户自己定义的异常。用户定义的异常，必须由用户自己抛出<code>throw new MyException</code>。</p><p>自定义异常语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class [自定义异常名] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-comment">// body</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>throw</code>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> [异常对象]<br></code></pre></td></tr></table></figure><p><strong>注意事项：程序会在<code>throw</code>语句处立即终止，转向<code>try...catch</code>寻找异常处理方法。</strong></p><blockquote><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MyException.java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>MyException(<span class="hljs-type">int</span> a) &#123;<br>  <span class="hljs-built_in">this</span>.x = a;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyException&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> MyException &#123;<br>  System.out.println(<span class="hljs-string">&quot;\t此处引用method (&quot;</span> + a + <span class="hljs-string">&quot;)&quot;</span>);<br>  <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>) <br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(a);<br>  System.out.println(<span class="hljs-string">&quot;正常返回&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;进入异常监视区&quot;</span>);<br>      method(<span class="hljs-number">8</span>);<br>      method(<span class="hljs-number">15</span>);<br>      method(<span class="hljs-number">7</span>);<br>  &#125; <span class="hljs-keyword">catch</span>(MyException e) &#123;<br>      System.out.println(<span class="hljs-string">&quot;\t&quot;</span> + e.toString());<br>  &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="7、try-catch、throws、throw的区别"><a href="#7、try-catch、throws、throw的区别" class="headerlink" title="7、try...catch、throws、throw的区别"></a>7、<code>try...catch</code>、<code>throws</code>、<code>throw</code>的区别</h3><ul><li><p><strong><code>try...catch</code></strong>使用在<strong>方法中</strong>，用来<strong>捕获异常</strong>。</p><p><strong><code>throws</code></strong>用在<strong>方法的声明处</strong>，用来<strong>声明抛出异常</strong>。</p></li><li><p><strong><code>throws</code></strong>语句在<strong>方法声明处</strong>声明<strong>抛出特定的异常</strong>。</p><p><strong><code>throw</code></strong>语句在<strong>方法中</strong>抛出<strong>具体的异常</strong>。</p></li></ul><h2 id="十一、Java-IO"><a href="#十一、Java-IO" class="headerlink" title="十一、Java IO"></a>十一、Java IO</h2><h3 id="（一）基本输入输出"><a href="#（一）基本输入输出" class="headerlink" title="（一）基本输入输出"></a>（一）基本输入输出</h3><h4 id="1、命令行输入"><a href="#1、命令行输入" class="headerlink" title="1、命令行输入"></a>1、命令行输入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandLineArgu</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;args[&quot;</span> + i +<span class="hljs-string">&quot;] is \&quot;&quot;</span> + args[i] + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&gt;&gt;&gt; javac CommandLineArgu.java<br>&gt;&gt;&gt; java CommandLineArgu arg0 arg1 arg2<br><span class="hljs-built_in">args</span>[<span class="hljs-number">0</span>] <span class="hljs-built_in">is</span> <span class="hljs-string">&quot;arg0&quot;</span><br><span class="hljs-built_in">args</span>[<span class="hljs-number">1</span>] <span class="hljs-built_in">is</span> <span class="hljs-string">&quot;arg1&quot;</span><br><span class="hljs-built_in">args</span>[<span class="hljs-number">2</span>] <span class="hljs-built_in">is</span> <span class="hljs-string">&quot;arg2&quot;</span><br></code></pre></td></tr></table></figure><p><strong>注：<code>args[0]</code>是从不包括程序名称的第一个参数开始。</strong></p><h4 id="2、标准输入输出"><a href="#2、标准输入输出" class="headerlink" title="2、标准输入输出"></a>2、标准输入输出</h4><ul><li><p><strong>标准输入输出中有三个基本的<code>I/O</code>对象</strong></p><blockquote><ul><li>标准输入：<code>System.in</code></li><li>标准输出：<code>System.out</code></li><li>标准错误：<code>System.err</code></li></ul></blockquote></li><li><p><strong><code>java.util.Scanner</code></strong></p><p><code>Scanner</code>通过<strong>分隔符模式</strong>将输入分解为标记，默认情况下<strong>该分隔符模式与空白匹配。</strong></p><ul><li><p>定义输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure></li><li><p>输入写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入一个word</span><br>in.next();<br><span class="hljs-comment">// 输入接下来一行</span><br>in.nextLine();<br><span class="hljs-comment">// 输入一个int类型的数</span><br>in.nextInt();<br><span class="hljs-comment">// 可以通过使用不同的next方法将得到的标记转换为不同类型的值</span><br></code></pre></td></tr></table></figure><blockquote><h5 id="关于next-和nextLine-的细节"><a href="#关于next-和nextLine-的细节" class="headerlink" title="关于next()和nextLine()的细节"></a>关于<code>next()</code>和<code>nextLine()</code>的细节</h5><p>通过<code>Scanner</code>类的<code>next()</code>与<code>nextLine()</code>方法获取输入的字符串，在读取前我们一般需要使用hasNext()与<code>hasNextLine</code>判断是否还有输入的数据。</p><ul><li><p><code>next()</code></p><p>只读取输入直到空格。它不能读两个由空格或符号隔开的单词。此外，<code>next()</code>在读取输入后，光标放在同一行。<strong>即<code>next()</code>只读取空格之前的数据，并且将光标指向本行。</strong></p></li><li><p><code>nextLine()</code></p><p>读取输入，包括单词之间的空格和除了回车以外的所有符号<strong>（即读完一整行，读到行尾）</strong>。读取输入后，<code>nextLine()</code>将光标定位在下一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title function_">readWord</span><span class="hljs-params">()</span> &#123;<br>        ArrayList&lt;String&gt; words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">while</span> (!in.hasNext(<span class="hljs-string">&quot;0&quot;</span>)) &#123; <span class="hljs-comment">// 这里设置一个循环终止标志的目的是为了避免死循环，下同</span><br>            words.add(in.next());<br>        &#125;<br>        <span class="hljs-keyword">return</span> words;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title function_">readLine</span><span class="hljs-params">()</span> &#123;<br>        ArrayList&lt;String&gt; lines = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">while</span> (!in.hasNext(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            lines.add(in.nextLine());<br>        &#125;<br>        <span class="hljs-keyword">return</span> lines;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readAndShow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 需要注意的是：要按照顺序输入int, double, string类型的数据。</span><br>        <span class="hljs-comment">/* eg：</span><br><span class="hljs-comment">        输入：1 1.5 Java </span><br><span class="hljs-comment">        输出：i = 1, d = 1.5, s = Java</span><br><span class="hljs-comment">        若不按顺序</span><br><span class="hljs-comment">        输入：1.5 1 Java</span><br><span class="hljs-comment">        输出：i = 0, d = 1.5, s = 1</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (in.hasNextInt()) &#123;<br>            i = in.nextInt(); <span class="hljs-comment">// 读一个整数</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (in.hasNextDouble()) &#123;<br>            d = in.nextDouble(); <span class="hljs-comment">// 读一个浮点数</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (in.hasNext()) &#123;<br>            s = in.next(); <span class="hljs-comment">// 读一个单词</span><br>        &#125;<br>        System.out.println(String.format(<span class="hljs-string">&quot;i = %d, d = %.2f, s = %s&quot;</span>, i, d, s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote></li></ul></li></ul><h3 id="（二）文件与数据流"><a href="#（二）文件与数据流" class="headerlink" title="（二）文件与数据流"></a>（二）文件与数据流</h3><h4 id="1、Java文件管理（File类）"><a href="#1、Java文件管理（File类）" class="headerlink" title="1、Java文件管理（File类）"></a>1、Java文件管理（<code>File</code>类）</h4><h5 id="1）概念"><a href="#1）概念" class="headerlink" title="1）概念"></a>1）概念</h5><ul><li><code>File</code>类代表<strong>与平台无关</strong>的文件和目录。</li><li><code>File</code>类能新建、删除、重命名文件和目录。</li><li><code>File</code>类一般不涉及文件内部的具体内容，而是从整体上对文件进行处理，因此<code>File</code>类不能访问文件内容本身。<strong>如果需要访问文件内容本身，则需要使用文件输入/输出流（<code>FileInputStream/FileOutputStream</code>)</strong></li><li>在Java文件体系中，文件和目录是统一抽象成文件来处理的。</li><li><strong>如果一个<code>File</code>是目录的话，可以使用<code>list()</code>方法</strong>取得文件名列表以及子目录结构等。</li></ul><h5 id="2）主要方法"><a href="#2）主要方法" class="headerlink" title="2）主要方法"></a>2）主要方法</h5><ul><li><p><strong>构造方法</strong></p><p><code>File</code>类有四个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">File(File parent, String child);<br>File(String pathName);<br>File(String parent, String child);<br>File(URI uri);<br></code></pre></td></tr></table></figure><p><strong>注意：这里的对象指的可以是一个我们通常所说的文件，也可以是一个目录（路径）；可以是个具体存在的文件，也可以是个尚未存在的文件。</strong></p></li><li><p><strong>常用方法</strong></p><ul><li><p><strong>访问文件名</strong></p><table><thead><tr><th>String getName()</th><th>取得文件名</th></tr></thead><tbody><tr><td><strong>String getPath</strong></td><td><strong>取得文件路径</strong></td></tr><tr><td><strong>File getParentFile()</strong></td><td><strong>取得父目录对象，不存在时返回null</strong></td></tr><tr><td><strong>String getAbsolutePath()</strong></td><td><strong>取得绝对路径</strong></td></tr><tr><td><strong>String getParent()</strong></td><td><strong>取得父目录名，不存在时返回null</strong></td></tr><tr><td><strong>boolean renameTo(File dest)</strong></td><td><strong>重命名文件</strong></td></tr></tbody></table></li><li><p><strong>文件检测</strong></p><table><thead><tr><th>boolean exists()</th><th>测试文件是否存在，存在即返回true</th></tr></thead><tbody><tr><td><strong>boolean canWrite()</strong></td><td><strong>文件存在并可写，返回true</strong></td></tr><tr><td><strong>boolean canRead()</strong></td><td><strong>文件存在并可读，返回true</strong></td></tr><tr><td><strong>boolean isFile()</strong></td><td><strong>如果是文件，返回true</strong></td></tr><tr><td><strong>boolean isDiretory()</strong></td><td><strong>如果是目录，返回true</strong></td></tr></tbody></table></li><li><p><strong>获取常规文件信息</strong></p><table><thead><tr><th>long lastModified()</th><th>返回文件的最后修改时间</th></tr></thead><tbody><tr><td><strong>long length()</strong></td><td><strong>返回文件的长度</strong></td></tr></tbody></table></li><li><p><strong>文件操作相关</strong></p><table><thead><tr><th>boolean createNewFile()</th><th>如果文件不存在，就创建它</th></tr></thead><tbody><tr><td><strong>boolean delete()</strong></td><td><strong>删除一个文件或目录</strong></td></tr></tbody></table></li><li><p><strong>目录操作相关</strong></p><table><thead><tr><th>boolean mkdir()</th><th>创建一个目录</th></tr></thead><tbody><tr><td><strong>boolean mkdirs()</strong></td><td><strong>创建一个目录，包括所有必须但不存在的父目录</strong></td></tr><tr><td><strong>String[] list()</strong></td><td><strong>列出这个目录下的文件和子目录</strong></td></tr><tr><td><strong>String[] list(FilenameFilter filter)</strong></td><td><strong>有文件过滤器的list</strong></td></tr><tr><td><strong>File[] listFiles()</strong></td><td><strong>列出这个目录下的文件和子目录的File对象</strong></td></tr><tr><td><strong>File[] listFiles(FileFilter filter)</strong></td><td><strong>有文件过滤器的listFiles</strong></td></tr></tbody></table></li></ul></li></ul><h4 id="2、输入输出流"><a href="#2、输入输出流" class="headerlink" title="2、输入输出流"></a>2、输入输出流</h4><h5 id="1）概念-1"><a href="#1）概念-1" class="headerlink" title="1）概念"></a>1）概念</h5><p>数据流：数据流是指一组有顺序的、有起点和终点的字节集合。</p><p>Java程序不能直接操作I/O设备，而是在程序和设备之间加入了一个中间介质，这就是<strong>流(Stream)</strong>。建立流实际上就是<strong>建立数据传输通道</strong>，将起点和终点连接起来。</p><ul><li>输入流：将数据从文件、标准输入或其他外部设备输入加载到内存。</li><li>输出流：将内存中的数据保存到文件中、或传输给输出设备。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">- InputStream<br>- OutputStream<br>- Reader<br>Object- Writer<br>- File<br>- RandomAccessFile<br></code></pre></td></tr></table></figure><h5 id="2）分类"><a href="#2）分类" class="headerlink" title="2）分类"></a>2）分类</h5><blockquote><ul><li>输入数据流：只能读，不能写<ul><li>字节流：InputStream的子类</li><li>字符流：Reader的子类</li></ul></li><li>输出数据流：只能写，不能读<ul><li>字节流：OutputStream的子类</li><li>字符流：Writer的子类</li></ul></li></ul></blockquote><h5 id="3）I-O流"><a href="#3）I-O流" class="headerlink" title="3）I/O流"></a>3）I/O流</h5><blockquote><p><strong><code>InputStream</code></strong></p><ul><li><p><code>FileInputStream</code>用于从本地文件中读取数据。</p></li><li><p><code>PipedInputStream</code>用于管道输入/输出时从管道中读取数据。</p></li><li><p><code>FilterInputStream</code>子类</p><ul><li><code>DataInputStream</code>是读取Java中的基本数据类型。</li><li><code>PushbackStream</code>读取数据时对数据进行缓冲，提高效率，增加特殊功能。</li><li><code>BufferedInputStream</code>读取数据时对数据进行缓冲，提高效率，增加特殊功能。</li></ul></li><li><p><code>ByteArrayInputStream</code>包含一个内存缓冲区，用于从内存中读取数据。</p></li><li><p><code>SequencedInputStream</code>把两个或者更多的<code>InputStream</code>输入流对象转换为单个的<code>InputStream</code>输入流对象使用。</p></li><li><p><code>ObjectInputStream</code>用来读取对象。</p></li><li><p><code>AudioInputStream</code>用于<code>Audio</code>的输入输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常用方法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">available</span><span class="hljs-params">()</span>;<br><span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li></ul><p><strong><code>OutputStream</code></strong></p><ul><li><p><code>FileOutputStream</code>用于向本地文件中写入数据。</p></li><li><p><code>PipedOutputStream</code>用于管道输入/输出时把数据向管道输出。</p></li><li><p><code>FilterOutputStream</code>子类</p><ul><li><code>DataOutputStream</code>提供对基本数据类型的支持。</li><li><code>BufferedOutputStream</code></li><li><code>PrintStream</code>提供了向屏幕输出有格式数据的方法。</li></ul></li><li><p><code>ObjectOutputStream</code>用来输出对象。</p></li><li><p><code>ByteArrayOutputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常用方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buffer, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li></ul><p><strong><code>Reader</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">- BufferedReader &lt;- LineNumberReader<br>        - CharArrayReader<br>        - StringReader<br>Reader &lt;-<br>            - InputStreamReader &lt;- FileReader<br>            - PipedReader<br>            - FilterReader &lt;- PushbackReader<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//常用函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cbuf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cbuf, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br>String <span class="hljs-title function_">readLine</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">ready</span><span class="hljs-params">()</span>;<br><span class="hljs-type">long</span> <span class="hljs-title function_">skip</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">markSupported</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readAheadLimit)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p><strong><code>Writer</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">- BufferedWriter<br>            - CharArrayWriter<br>            - StringWriter<br>Writer &lt;- - OutputStreamWriter &lt;- FileWriter<br>            - PrintWriter<br>            - PipedWriter<br>            - FilterWriter<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常用函数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cbuf)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cbuf,l <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String string)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String string, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>BUAA</category>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BUAA</tag>
      
      <tag>OO</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组-总线与IO概述</title>
    <link href="/2023/01/29/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E4%B8%8EIO%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/01/29/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E4%B8%8EIO%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>BUAA 软院 大二 计组 总线与 I/O</p><span id="more"></span><h1 id="总线和I-O"><a href="#总线和I-O" class="headerlink" title="总线和I/O"></a>总线和I/O</h1><h2 id="1、总线的仲裁"><a href="#1、总线的仲裁" class="headerlink" title="1、总线的仲裁"></a>1、总线的仲裁</h2><p><strong>总线的仲裁方式</strong></p><ul><li><p>集中式仲裁方式</p><ul><li><p>链式查询方式</p><blockquote><ul><li>总线控制器（仲裁器）收到总线申请 BR、BG（总线<strong>同意</strong>信号）逐个往下传。</li><li>遇到某接口有总线申请（BR：总线申请信号），BG 停止往下传。</li><li>该接口获得总线使用权，并建立总线忙信号 BS。</li><li><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="总线IO-链式查询方式"></li></ul></blockquote></li><li><p>计数器定时查询方式</p><blockquote><ul><li>总线控制器（仲裁器）收到总线申请 BR，仲裁器上的计数器开始计数。</li><li>当某个有总线申请的设备地址与计数器一致，便获得总线使用权，并建立总线忙信号BS。</li><li><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="总线IO-计数器定时查询方式"></li></ul></blockquote></li><li><p>独立请求方式</p><blockquote><ul><li>每个设备有独立的请求信号和总线同意信号。</li><li>总线控制器根据设备的优先级决定将总线的使用权交给哪一个设备。</li><li><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png" alt="总线IO-独立请求方式"></li></ul></blockquote></li></ul></li><li><p>分布式仲裁方式</p><ul><li>自举分布式仲裁</li><li>冲突检测分布式仲裁</li><li>并行竞争分布式仲裁</li></ul></li></ul><h2 id="2、I-O接口"><a href="#2、I-O接口" class="headerlink" title="2、I/O接口"></a>2、I/O接口</h2><p>外部设备并不是直接挂接在系统总线上，而是通过 I/O 接口为桥梁实现与系统总线的连接。</p><ul><li>各种外设使用不同的操作方法，有 CPU 来直接控制不同的外设不切实际。</li><li>外设的数据传送速度比存储器和处理器的速度慢得多，使用高速的系统总线与慢速的外设直接连接，不切实际。</li><li>外设经常使用与处理器不同的数据格式和字长度。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/IO%E6%8E%A5%E5%8F%A3.png" alt="IO接口"></p><h3 id="2-1、I-O接口的功能"><a href="#2-1、I-O接口的功能" class="headerlink" title="2.1、I/O接口的功能"></a>2.1、I/O接口的功能</h3><ul><li>识别 I/O 地址，即地址译码。</li><li>实现主机与 I/O 设备的数据交换，控制命令的传递和状态检测与传递。</li><li>提供缓冲和驱动能力。</li><li>进行数据格式、类型方面的转换（串并行转换，电平转换等）。</li><li>支持一定的 I/O 方式（程序查询、程序中断、DMA 等）。</li><li>I/O 控制与定时。</li></ul><h3 id="2-2、I-O-接口的分类"><a href="#2-2、I-O-接口的分类" class="headerlink" title="2.2、I/O 接口的分类"></a>2.2、I/O 接口的分类</h3><ul><li>按传输数据格式：<ul><li>串行接口<ul><li>适合速度低，传输距离长的环境</li></ul></li><li>并行接口<ul><li>适合速度高，传输距离短的环境</li></ul></li></ul></li><li>按 I/O 方式分类<ul><li>程序查询接口</li><li>中断接口</li><li>DMA 接口</li><li>通道控制接口</li></ul></li><li>按时序控制方式<ul><li>同步接口<ul><li>数据传送由一个统一的时钟信号同步控制。</li></ul></li><li>异步接口<ul><li>数据传送采用异步应答方式控制</li></ul></li></ul></li></ul><h3 id="2-3、I-O-设备的编址"><a href="#2-3、I-O-设备的编址" class="headerlink" title="2.3、I/O 设备的编址"></a>2.3、I/O 设备的编址</h3><ul><li>编址方式<ul><li>独立编址方式：存储器地址与 I/O 地址分开，CPU 具有专用的 I/O 指令，系统总线中具有区别存储器读写和 I/O 操作的控制信号，并以此区别地址总线上的地址时存储器地址还是 I/O 地址。</li><li>统一编址方式：存储器地址与 I/O 地址统一考虑，地址空间的一部分是存储器，另一部分是 I/O，支持存储器操作的指令都可以用于 I/O 操作。</li></ul></li><li>I/O 地址（I/O 接口地址、I/O 端口地址）：实际是 I/O 接口电路中寄存器的地址。</li></ul><h2 id="3、程序查询-I-O-方式"><a href="#3、程序查询-I-O-方式" class="headerlink" title="3、程序查询 I/O 方式"></a>3、程序查询 I/O 方式</h2><ul><li><p>也称编程式 I/O，处理器执行程序直接控制 I/O，包括：</p><ul><li>检测设备状态</li><li>发送读写命令（处理器发送 I/O 命令后，必须等待，直到 I/O 接口状态就绪）</li><li>传送数据</li></ul></li><li><p>I/O 命令</p><ul><li>控制命令：激活外设完成动作。如：指示磁带机快进或后退，控制命令与设备类型相关。</li><li>测试命令：测试与 I/O 接口及其外部设备的各种状态条件。</li><li>读命令：使 I/O 接口从外设获得一个数据项，存入内部缓冲区。</li><li>写命令：使 I/O 接口从数据总线获得一个数据项，然后传送到外设。</li><li><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2IO%E6%B5%81%E7%A8%8B.png" alt="总线IO-程序查询IO流程"></li></ul></li><li><p>程序查询 I/O 接口的基本组成：</p><ul><li>状态寄存器</li><li>数据寄存器（输入寄存器，输出寄存器）</li><li>寻址选择逻辑</li><li>总线接口逻辑</li></ul></li><li><p>程序查询 I/O 方式的特点：</p><ul><li>I/O 操作由 CPU 直接完成（通过执行 I/O 指令完成）。</li><li>外设速度慢，CPU 速度快，CPU 处在不断地查询之中，CPU 效率浪费严重。</li><li>外设与 CPU 完全串行工作。</li></ul></li></ul><h2 id="4、中断与中断-I-O-方式"><a href="#4、中断与中断-I-O-方式" class="headerlink" title="4、中断与中断 I/O 方式"></a>4、中断与中断 I/O 方式</h2><p>中断：当机器出现一些紧急事务，CPU 不得不停下当前正在执行的程序，转去处理紧急事务，当紧急事务处理完后，继续执行被中断的程序。</p><blockquote><p>一般情况下，中断是随机的</p><ul><li>主程序：被中断的程序；</li><li>终端服务子程序：处理中断事务的程序。</li><li><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.png" alt="总线IO-中断流程"></li></ul></blockquote><ul><li><p>引起中断的因素（中断源）：</p><ul><li>人为设置的中断（软中断 SWI ）：主动中断。</li><li>程序性事故：如溢出、除零等。</li><li>硬件故障：如电源掉电、磁盘损坏。</li><li>外部事件：如键盘操作。</li></ul></li><li><p>中断源分类：</p><ul><li>不可屏蔽中断：CPU 不能不响应。</li><li>可屏蔽中断：若中断源被屏蔽，CPU 不响应。</li></ul></li><li><p>中断的分类：</p><ul><li>非屏蔽中断与可屏蔽中断。</li><li>硬中断与软中断（软中断不是真正的中断）。</li></ul></li><li><p>中断请求：</p><ul><li>中断请求触发器（INTR）：每个中断源配置一个中断请求触发器。</li><li>中断请求标记寄存器：各中断源的请求触发器组成中断请求标记寄存器。</li><li><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82.png" alt="总线IO-中断请求"></li></ul></li></ul><h2 id="5、DMA-I-O方式"><a href="#5、DMA-I-O方式" class="headerlink" title="5、DMA I/O方式"></a>5、DMA I/O方式</h2><h3 id="5-1、DMA-一般概念"><a href="#5-1、DMA-一般概念" class="headerlink" title="5.1、DMA 一般概念"></a>5.1、DMA 一般概念</h3><ul><li>程序 I/O 和中断 I/O 的不足：<ul><li>I/O 传送速度受处理器测试和服务设备速度的限制。</li><li>处理器直接负责管理 I/O，对于每一次 I/O 传送，处理器必须执行一些指令。</li><li>考虑批量（数据块）传送：<ul><li>程序查询 I/O 方式：处理器做不了其他事情。</li><li>中断 I/O 方式：I/O 传输效率较低。</li></ul></li></ul></li><li>DMA（Direct Memory Access)<ul><li>CPU 对总线的控制被临时禁止。</li><li>DMA 控制器接管总线控制权，控制数据直接在存储器与外设之间高速交换，CPU 不在介入具体的 I/O 操作，由 DMA 控制器来负责提供存储器地址信号，读写控制信号等。</li><li>CPU 与 I/O 设备在更大的程度上并行工作，效率更高。</li><li>DMA 方式适合高速批量的数据传输，如视频显示刷新、磁盘储存系统的读写、存储器到存储器的传输等。</li></ul></li></ul><h3 id="5-2、DMA-过程"><a href="#5-2、DMA-过程" class="headerlink" title="5.2、DMA 过程"></a>5.2、DMA 过程</h3><ul><li>DMA 操作：<ul><li>DMA 控制器在接到 DMA 应答信号后，通过控制逻辑向系统总线发送存储器地址信号、存储器读写控制信号、I/O 接口读写控制信号等，完成一次数据传送。这些操作完全由 DMA 控制器完成。若是单字传输，一般仅需要一个总线周期，所以这种方式称为<strong>周期窃取（cycle-stealing，或者叫周期挪用）方式</strong>。若是成组传输，需要多个总线周期来完成。</li><li>所有数据传送结束后，通过中断方式告知 CPU 进行善后处理。</li><li>CPU 仅在开始 DMA 操作之前和完成 DMA 操作之后参与 I/O 处理，在 DMA 过程中，CPU 可以运行原来的程序。</li></ul></li><li>DMA 方式：<ul><li>停止 CPU 访问内存（成组传送方式） <ul><li>一次 DMA 请求得到响应后，DMA 控制器完全占用总线，进行块数据（多字）传送，直到所有数据传送完毕才释放总线，这段时间完全停止 CPU 访问内存。</li><li>适应高速外设与存储器交换数据的情况。</li></ul></li><li>周期窃取方式（单字传送方式，DMA 和 CPU 交替使用总线）<ul><li>每次 DMA 请求得到响应后，DMA 控制器窃取一个总线周期完成一次数据传送，然后释放总线，CPU 接着使用一个总线周期，然后 DMA 再窃取一个周期，这样持续循环下去，直到数据传输结束。</li><li>一般适应存储器速度远高于 I/O 设备速度的情况。</li></ul></li></ul></li></ul><h3 id="5-3、DMA-控制器的结构"><a href="#5-3、DMA-控制器的结构" class="headerlink" title="5.3、DMA 控制器的结构"></a>5.3、DMA 控制器的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-DMA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A5%E5%8F%A3.png" alt="总线IO-DMA控制器接口"></p><h3 id="5-4、DMA-控制器类型"><a href="#5-4、DMA-控制器类型" class="headerlink" title="5.4、DMA 控制器类型"></a>5.4、DMA 控制器类型</h3><ul><li>选择型 DMA 控制器<ul><li>物理上可以链接多个 I/O 接口（外设）；</li><li>逻辑上只能连接一个设备，即在某一时间段只能为其中一台外设服务。</li><li>适用于数据传输率很高（接近于内存）的外设数据传输服务。</li><li><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-%E9%80%89%E6%8B%A9%E5%9E%8BDMA%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="总线IO-选择型DMA控制器"></li></ul></li><li>多路型 DMA 控制器<ul><li>物理上可以连接多个 I/O 接口（外设）；</li><li>逻辑上也可以连接多个设备，可通过交叉服务的方式为多台外设服务；</li><li>多路型DMA控制器内部应包括多个 DMA 通道；</li><li>适应于多个慢速（相对）外设的数据传输服务。</li><li><img src="https://cdn.jsdelivr.net/gh/authormq/PicForMyBlog@master/2023/01/%E8%AE%A1%E7%BB%84-%E6%80%BB%E7%BA%BF%E5%92%8CIO%E6%A6%82%E8%BF%B0/%E6%80%BB%E7%BA%BFIO-%E5%A4%9A%E8%B7%AF%E5%9E%8BDMA%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="总线IO-多路型DMA控制器"></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>BUAA</category>
      
      <category>计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BUAA</tag>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++标准模板库-STL</title>
    <link href="/2023/01/28/C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93-STL/"/>
    <url>/2023/01/28/C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93-STL/</url>
    
    <content type="html"><![CDATA[<p>C++标准模板库（STL）</p><span id="more"></span><h1 id="C-标准模板库"><a href="#C-标准模板库" class="headerlink" title="C++ 标准模板库"></a>C++ 标准模板库</h1><blockquote><p>C++标准模板库：STL（Standard Template Library)，封装了很多实用的容器。STL 大致可分为三类：算法（Algorithm）、容器（Container）、迭代器（Iterator）。</p><ul><li>容器：容器用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如：deque、list、vector、map 等。</li><li>算法：算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</li><li>迭代器：迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</li></ul></blockquote><h2 id="1、STL-的概述"><a href="#1、STL-的概述" class="headerlink" title="1、STL 的概述"></a>1、STL 的概述</h2><p>在 C++ 的标准中，STL 被组织为一组头文件（<strong>没有<code>.h</code>后缀</strong>）：</p><p><code>&lt;algorithm&gt;</code> <code>&lt;deque&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;iterator&gt;</code> <code>&lt;list&gt;</code> <code>&lt;map&gt;</code> <code>&lt;memory&gt;</code> <code>&lt;numeric&gt;</code> <code>&lt;queue&gt;</code> <code>&lt;set&gt;</code> <code>&lt;satck&gt;</code> <code>&lt;utility&gt;</code> <code>&lt;vector&gt;</code></p><p>当我们需要使用 STL 的某个功能时，需要嵌入相应的头文件。</p><ul><li><p>在 C++ 标准中，STL 是定义在 std 命名空间中的。使用 STL 时需要如下使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果希望在程序中，直接引入 STL，也可以在嵌入头文件后，用<code>using namespace std</code>语句将 std 命名空间导入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2、STL-的内容"><a href="#2、STL-的内容" class="headerlink" title="2、STL 的内容"></a>2、STL 的内容</h2><h3 id="2-1、vector"><a href="#2-1、vector" class="headerlink" title="2.1、vector"></a>2.1、vector</h3><p>vector：向量容器模板类。vector 容器以连续数组的方式存储元素序列，因此可以将 vector 视为以顺序结构实现的线性表。类似于 Java 中的 ArrayList。vector 在使用的过程中，可以动态的实现存储空间的增长（类动态数组）。</p><ul><li>vector 模板类需要两个模板参数，第一个参数是存储元素的数据类型。第二个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参数，将使用默认的分配器。</li><li>使用 vector 需要添加头文件<code>#include &lt;vector&gt;</code>。</li></ul><h4 id="1）vector-定义与初始化"><a href="#1）vector-定义与初始化" class="headerlink" title="1）vector 定义与初始化"></a>1）vector 定义与初始化</h4><p>单独定义一个 vector：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">typename</span>&gt; name;<br><span class="hljs-comment">// typename可以是基本类型（int、double、char、结构体），也可以是STL模板（vector、set、queue）。</span><br></code></pre></td></tr></table></figure><h5 id="（1）不带参数的构造函数初始化"><a href="#（1）不带参数的构造函数初始化" class="headerlink" title="（1）不带参数的构造函数初始化"></a>（1）不带参数的构造函数初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化一个size = 0的vector</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vt;<br></code></pre></td></tr></table></figure><h5 id="（2）带参数的构造函数初始化"><a href="#（2）带参数的构造函数初始化" class="headerlink" title="（2）带参数的构造函数初始化"></a>（2）带参数的构造函数初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化size, 但是每一个元素均为默认值</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vt</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 初始化了10个值为0的元素</span><br><span class="hljs-comment">// 初始化size，并且给每一个元素设置初始值</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vt</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 初始化了10个值为1的元素</span><br></code></pre></td></tr></table></figure><h5 id="（3）通过数组地址初始化"><a href="#（3）通过数组地址初始化" class="headerlink" title="（3）通过数组地址初始化"></a>（3）通过数组地址初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// 通过数组a的地址初始化。</span><br><span class="hljs-comment">// PS：地址从0-5，并且左闭右开，即[0, 5)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vt</span><span class="hljs-params">(a, a + <span class="hljs-number">5</span>)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="（4）通过同类型的-vector-初始化"><a href="#（4）通过同类型的-vector-初始化" class="headerlink" title="（4）通过同类型的 vector 初始化"></a>（4）通过同类型的 vector 初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">src</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-comment">// 通过src进行初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">desk</span><span class="hljs-params">(src)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="（5）通过-insert-初始化"><a href="#（5）通过-insert-初始化" class="headerlink" title="（5）通过 insert 初始化"></a>（5）通过 insert 初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// insert初始化方式将同类型的爹爱妻对应的始末区间（左闭右开）内的值插入到vector中</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">src</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>)</span></span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; desk;<br><span class="hljs-comment">// 将src[0]~src[2]插入到desk中，b.size()由0变为3</span><br>desk.<span class="hljs-built_in">insert</span>(desk.<span class="hljs-built_in">begin</span>(), src.<span class="hljs-built_in">begin</span>(), src.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><ul><li><p>insert 也可以通过数组的地址区间实现插入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt; vt;<br><span class="hljs-comment">// 将a的所有元素插入到vt中，区间左闭右开</span><br>vt.<span class="hljs-built_in">insert</span>(vt.<span class="hljs-built_in">begin</span>(), a, a + <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure></li><li><p>insert 还可以插入 m 个值为 n 的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在vt开始的地方插入6个6</span><br>b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">6</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="2）vector-容器内元素的访问"><a href="#2）vector-容器内元素的访问" class="headerlink" title="2）vector 容器内元素的访问"></a>2）vector 容器内元素的访问</h4><p>vector 一般有两种访问方式：</p><ul><li><p>通过下标访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typename</span> val = vt[index];<br></code></pre></td></tr></table></figure></li><li><p>通过迭代器访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">typename</span>&gt;::iterator it = vt.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// vt.begin()为vt元素首地址</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p><strong>PS：</strong></p><ul><li><code>vt[i]</code>和<code>vt.begin() + i</code>等价。</li><li><code>vt.end()</code>不是<code>vt</code>的尾元素地址，而是<strong>尾元素的下一个地址</strong>。在 C++ 中，区间的范围大多都是<strong>左闭右开</strong>。</li></ul></blockquote><h4 id="3）vector-的常用函数"><a href="#3）vector-的常用函数" class="headerlink" title="3）vector 的常用函数"></a>3）vector 的常用函数</h4><ul><li><p><code>front()</code>：返回首元素，时间复杂度 $O(1)$。</p></li><li><p><code>back()</code>：返回尾元素，时间复杂度 $O(1)$。</p></li><li><p><code>push_back(val)</code>：向表尾插入元素val，时间复杂度 $O(1)$。</p></li><li><p><code>size()</code>：返回表长，vector 元素个数，时间复杂度 $O(1)$。</p></li><li><p><code>empty()</code>：当表空时，返回真，否则，返回假。</p></li><li><p><code>pop_back()</code>：删除表尾元素，时间复杂度 $O(1)$。</p></li><li><p><code>begin()</code>：返回指向首元素的随机存取迭代器。</p></li><li><p><code>end()</code>：返回指向尾元素的下一个位置的的随机存取迭代器。</p></li><li><p><code>insert</code></p><ul><li><code>insert(it, x)</code>：向迭代器指向的元素前插入新元素 x。</li><li><code>insert(it, n, x)</code>：向迭代器指向的元素前插入 n 个元素 x。</li><li><code>insert(it, first, last)</code>：将迭代器 first 和 last 所指定的序列<code>[first, last)</code>插入到迭代器 it 指向的元素的前面。</li></ul></li><li><p><code>erase(it)</code>：删除由迭代器 it 所指向的元素。</p></li><li><p><code>erase(first, last)</code>：删除由迭代器 first，last 所指定的序列<code>[first, last)</code>。</p></li><li><p><code>reserve(n)</code>：预分配缓冲空间，使 存储空间至少可容纳 n 个元素。</p></li><li><p><code>resize(n)</code>：改变序列的长度，超出的元素将会被删除，如果序列需要拓展（原空间小于 n），元素默认值将填满拓展出的空间。</p></li><li><p><code>resize(n, val)</code>：改变序列的长度，超出的元素将会被删除，如果序列需要拓展（原空间小于 n），将用 val 填满拓展出的空间。</p></li><li><p><code>clear()</code>：删除容器中所有的元素。</p></li><li><p><code>a.swap(b)</code>：将 a 与另一个 vector 对象进行交换。</p></li><li><p><code>assign(first, last)</code>：将序列替换成由迭代器 first 和 last 所指定的序列<code>[first, last)</code>。<code>[first, last)</code>不能是原序列的一部分。</p></li><li><p><code>reverse()</code></p><blockquote><p><code>reverse()</code>的使用需要引用头文件<code>#include &lt;algorithm&gt;</code>，并且没有返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>(itBegin, itEnd);<br><span class="hljs-comment">// 将迭代器itBegin和itEnd中的元素进行翻转。</span><br></code></pre></td></tr></table></figure></blockquote></li></ul><h4 id="4）vector-的遍历"><a href="#4）vector-的遍历" class="headerlink" title="4）vector 的遍历"></a>4）vector 的遍历</h4><p>vector 有三种遍历方法和两种逆序遍历。</p><ul><li><p>遍历：</p><ul><li><p>迭代器 iterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>    <span class="hljs-keyword">for</span> (it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>下标遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cout &lt;&lt; v[i] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>foreach</code>遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : v) &#123;<br>        cout &lt;&lt; val &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>逆序遍历：</p><ul><li><p>迭代器 iterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;::reverse_iterator it;<br>    <span class="hljs-keyword">for</span> (it = v.<span class="hljs-built_in">rbegin</span>(); it != v.<span class="hljs-built_in">rend</span>(); it++) &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>下标遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        cout &lt;&lt; v[i] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    Another:</span><br><span class="hljs-comment">    reverse(v.begin(), v.end());</span><br><span class="hljs-comment">    for (int i = 0; i &lt; v.size(); i++) &#123;</span><br><span class="hljs-comment">    cout &lt;&lt; v[i] &lt;&lt;  endl;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-2、set"><a href="#2-2、set" class="headerlink" title="2.2、set"></a>2.2、set</h3><p>set：集合容器模板类。是一个<strong>内部自动有序</strong>且<strong>不含重复元素</strong>的容器。set 作为一种关联容器，内部采用红黑树（平衡检索二叉树）结构。</p><ul><li>使用 set 需要添加头文件<code>#include &lt;set&gt;</code>。</li><li>set 中元素的值不能被更改。</li><li>multiset 与 set，unordered_set 与 unordered_multiset</li></ul><h4 id="1）set-的定义和初始化"><a href="#1）set-的定义和初始化" class="headerlink" title="1）set 的定义和初始化"></a>1）set 的定义和初始化</h4><p>单独定义一个 set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-keyword">typename</span>&gt; name;<br><span class="hljs-comment">// typename可以是基本类型（int、double、char、结构体），也可以是STL模板（vector、set、queue）。</span><br></code></pre></td></tr></table></figure><p>定义 set 数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-keyword">typename</span>&gt; arrayName[arraySize];<br><span class="hljs-comment">// arrayName[0]~arrayName[arraySize - 1]中每一个元素都是一个set容器。</span><br></code></pre></td></tr></table></figure><h4 id="2）set-中元素的访问和遍历"><a href="#2）set-中元素的访问和遍历" class="headerlink" title="2）set 中元素的访问和遍历"></a>2）set 中元素的访问和遍历</h4><p>set 只能通过迭代器进行访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-keyword">typename</span>&gt;::iterator it;<br><span class="hljs-comment">// eg:</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>set&lt;Node&gt;::iterator it;<br></code></pre></td></tr></table></figure><p><strong>由于除了 vector、deque、string 之外的 STL 容器都不支持 *(it + i) 的访问方式</strong>，因此枚举为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        st.<span class="hljs-built_in">insert</span>(i);<br>    &#125;<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>    <span class="hljs-keyword">for</span> (it = st.<span class="hljs-built_in">begin</span>(); it != st.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）常用函数"><a href="#3）常用函数" class="headerlink" title="3）常用函数"></a>3）常用函数</h4><p>set 与 vector 常用函数基本相同。</p><ul><li><p><code>insert(x)</code>：将元素 x 插入 set 中，并自动增序排序和去重，时间复杂度为 $O(logN)$。</p></li><li><p><code>find(val)</code>：返回set中对应值为 val 的迭代器，时间复杂度为 $O(logN)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        st.<span class="hljs-built_in">insert</span>(i);<br>    &#125;<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator it = st.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 在set中查找2，并返回其迭代器。</span><br>    cout &lt;&lt; *it &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>erase()</code>：删除元素函数</p><ul><li><p><code>st.erase(it)</code>：删除迭代器 it 出的元素，时间复杂度为 $O(1)$。</p></li><li><p><code>st.erase(val)</code>：删除元素 val，这里的 val 不再是迭代器。时间复杂度为 $O(logN)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        st.<span class="hljs-built_in">insert</span>(i);<br>    &#125;<br>    st.<span class="hljs-built_in">erase</span>(st.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 删除元素2</span><br>    <span class="hljs-comment">// st.erase(2); // 删除元素2</span><br>    <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = st.<span class="hljs-built_in">begin</span>(); it != st.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>erase(first, last)</code>：删除一个区间内的所有元素。first 为所需删除区间的起始迭代器，last 为所需删除区间的末尾迭代器的下一个地址。时间复杂度为 $O(last - first)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        st.<span class="hljs-built_in">insert</span>(i);<br>    &#125;<br>    st.<span class="hljs-built_in">erase</span>(st.<span class="hljs-built_in">find</span>(<span class="hljs-number">5</span>), st.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = st.<span class="hljs-built_in">begin</span>(); it != st.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>clear()</code>：清空 set 中的所有元素，时间复杂度为 $O(N)$。</p></li><li><p><code>size()</code>：获取 set 中元素的个数，返回类型为 unsigned 类型。时间复杂度为 $O(1)$。</p></li></ul><h3 id="2-3、string"><a href="#2-3、string" class="headerlink" title="2.3、string"></a>2.3、string</h3><p>string：一种字符串基本数据类型。在 C 语言中，通常采用字符数组或字符指针的方式来表示字符串；在 STL 库中，可以用 string 来表示字符串。</p><p>string 类本质上可以看作是一个字符的 vector，vector 上的各种操作都可以适用于 string。同时，string 类对象还支持字符串的拼接、转换等功能。</p><h4 id="1）string-的定义与初始化"><a href="#1）string-的定义与初始化" class="headerlink" title="1）string 的定义与初始化"></a>1）string 的定义与初始化</h4><p>定义方式与 int 等基本数据类型一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br>string str = <span class="hljs-string">&quot;Hello string!&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>需要添加头文件<code>#include &lt;string&gt;</code></li><li><strong>注意：</strong><code>string.h</code>和<code>string</code>是两个不一样的头文件。</li></ul><h4 id="2）string-内容的访问"><a href="#2）string-内容的访问" class="headerlink" title="2）string 内容的访问"></a>2）string 内容的访问</h4><h5 id="（1）通过下标访问"><a href="#（1）通过下标访问" class="headerlink" title="（1）通过下标访问"></a>（1）通过下标访问</h5><ul><li><p>一般情况下，可以直接通过字符数组的方式访问 string，如：<code>str[i]</code>。</p></li><li><p>如果要读入和输出<strong>整个字符串</strong>，只能使用<code>cin</code>和<code>cout</code>。</p></li><li><p>也可以使用<code>c_str()</code>将 string 类型转换为字符数组再输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str;<br>cin &gt;&gt; str;<br>cout &lt;&lt; str;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure></li></ul><h5 id="（2）通过迭代器访问"><a href="#（2）通过迭代器访问" class="headerlink" title="（2）通过迭代器访问"></a>（2）通过迭代器访问</h5><p>string 的迭代器定义方式不需要参数：<code>string::iterator it;</code></p><p>string 和 vector 一样，可以直接对迭代器进行加减处理，比如：<code>str.begin() + 2</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str = <span class="hljs-string">&quot;Hello string&quot;</span>;<br>    <span class="hljs-keyword">for</span> (string::iterator it = str.<span class="hljs-built_in">begin</span>(); it != str.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; *it;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）string-的常用方法"><a href="#3）string-的常用方法" class="headerlink" title="3）string 的常用方法"></a>3）string 的常用方法</h4><ul><li><p><code>operator+=</code>：string 的加法，实现字符串的拼接。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-built_in">string</span> str3 = str1 + str2;<br></code></pre></td></tr></table></figure></li><li><p><code>==</code> <code>!=</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code>：string 的比较函数，比较的规则是字典序。</p></li><li><p><code>length()</code> <code>size()</code>：<code>length()</code>返回 string 的长度，即存放的字符数，时间复杂度为 $O(1)$。</p></li><li><p><code>insert()</code>：string 的插入函数，时间复杂度为 $O(N)$。</p><ul><li><p><code>insert(pos, string)</code>：在 pos 位置插入字符串 string。</p></li><li><p><code>insert(it, it_begin, it_end)</code>：it 是原字符串的中待插入字符串的位置的迭代器，it_begin 和 it_end 为待插入字符串的首尾迭代器，表示 <code>[it_begin, it_end)</code>将被插在 it 的位置上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str = <span class="hljs-string">&quot;WelcomeToTheWorldOfSTL&quot;</span>;<br>    string temp = <span class="hljs-string">&quot;HelloString&quot;</span>;<br>    str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, temp);<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    str.<span class="hljs-built_in">insert</span>(str.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>erase()</code>：string 的删除函数。</p><ul><li><p><code>str.erase(it)</code>：删除 str 中迭代器为 it 的元素，删除单个元素。时间复杂度为 $O(N)$。</p></li><li><p><code>str.erase(first, last)</code>：删除<code>[first, last)</code>内的所有元素。其中 first 为所需删除区间的起始迭代器，last 为所需删除区间的末尾迭代器的下一个地址。时间复杂度为 $O(N)$。</p></li><li><p><code>str.erase(pos, length)</code>：pos 为需要开始删除的位置，length 为需要删除的字符的个数。时间复杂度为 $O(N)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string str = <span class="hljs-string">&quot;WelcomeToTheWorldOfSTL&quot;</span>;<br>    str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">begin</span>());<br>    str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>);<br>    str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>clear()</code>：清空字符串。时间复杂度为 $O(1)$。</p></li><li><p><code>substr()</code>：<code>sub(pos, len)</code>返回从 pos 位置开始，长度为 len 的子串。时间复杂度为 $O(len)$。</p></li><li><p><code>find()</code>：string 的查找函数。</p><ul><li><p><code>str.find(subString)</code>：当 subString 是 str 的字串时，返回其在 str 中第一次出现的位置；如果不是 str 的字串，返回<code>string::npos</code>。</p></li><li><p><code>str.find(subString, pos)</code>：从 str 的 pos 号位置开始匹配 subString，返回值同上。</p></li><li><blockquote><p><code>string::npos</code>：</p><p><code>string::npos</code>是一个常数，为 unsigned_int 类型。其值为 -1，因为属于 unsigned_int，因此也可认为是 unsigned_int 类型的最大值，即：4294967295。常用于作为<code>find()</code>函数失配时的返回值类型。</p></blockquote></li></ul></li><li><p><code>replace()</code>：string 的替换函数。</p><ul><li><code>str.replace(pos, len, repString)</code>：把 str 从 pos 位开始，长度为 len 的字符串替换成 repString。</li><li><code>str.replace(it_begin, it_end, repString)</code>：将 str 中迭代器为<code>[it_begin, it_end)</code>范围内的字串替换成 repString。</li></ul></li></ul><h3 id="2-4、map"><a href="#2-4、map" class="headerlink" title="2.4、map"></a>2.4、map</h3><p>在 STL 的头文件<code>#include &lt;map&gt;</code>中定义了模板类 map 和 multimap，用有序二叉树来存储类型的<code>pair&lt;const Key, T&gt;</code>的元素对序列。序列中的元素以 consy Key 部分作为标识，map 中所有的元素的 Key 值都必须是唯一的，multimap 允许有重复的 Key 值（即允许一个键映射到多个值）。</p><ul><li><p>map 作为一种映射，可以将任何基本类型（包括 STL 容器）映射到任何基本类型（包括 STL 容器）。</p></li><li><p>可以将 map 看作是由 Key 标识元素的元素集合，这类容器被称为“关联容器”，可以通过一个 Key 值来快速确定一个元素。</p></li><li><p>map 会以键从大到小的顺序自动排序，因为 map 内部是用<strong>红黑树</strong>实现的，在建立映射的过程中会自动实现从小到大的排序。</p></li><li><p>map 模板类需要四个模板参数：键值类型、元素类型、比较算子和分配器类型。其中键值类型和元素类型是必要的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Pred = less&lt;Key&gt;, <span class="hljs-keyword">typename</span> A = allocator&lt;Key&gt; &gt;<br><span class="hljs-keyword">class</span> map &#123; <br>    …… <br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">const</span> Key, T&gt; value_type;<br>    …… <br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>map 的键和值是唯一的，multimap 可以同时存储多个键相同的键值对。</p></li><li><p>unordered_map 以散列（哈希表）代替 map 内部的红黑树实现，可以用来处理只映射而不按照 key 排序，速度较 map 快得多。</p></li></ul><h4 id="1）map-的定义和初始化"><a href="#1）map-的定义和初始化" class="headerlink" title="1）map 的定义和初始化"></a>1）map 的定义和初始化</h4><p>使用 map 前需要先引入头文件<code>#include &lt;map&gt;</code>及<code>using namespace std</code>。</p><p>map 需要确定映射前类型（键 key）和映射后类型（值 value），所以需要在<code>&lt;&gt;</code>内填写两个类型，第一个为键的类型，第二个为值的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;keyTypename, valueTypename&gt; mp;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>如果是字符串到整数的映射，必须使用 string 而不能使用 char 数组。</p><h4 id="2）map-中内容的访问"><a href="#2）map-中内容的访问" class="headerlink" title="2）map 中内容的访问"></a>2）map 中内容的访问</h4><h5 id="（1）通过下标访问-1"><a href="#（1）通过下标访问-1" class="headerlink" title="（1）通过下标访问"></a>（1）通过下标访问</h5><p>由于 map 中键是唯一的，因此在访问 map 的过程中，可以向访问普通数组一样访问 map。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">10</span>;<br>mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">20</span>; <span class="hljs-comment">// 10被覆盖</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mp[<span class="hljs-string">&#x27;a&#x27;</span>]);<br></code></pre></td></tr></table></figure><h5 id="（2）通过迭代器访问-1"><a href="#（2）通过迭代器访问-1" class="headerlink" title="（2）通过迭代器访问"></a>（2）通过迭代器访问</h5><p>定义迭代器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;keyTypename, valueTypename&gt;::iterator it;<br></code></pre></td></tr></table></figure><p>用<code>it-&gt;first</code>来访问键，用<code>it-&gt;second</code>来访问值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>    mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">1</span>, mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">2</span>, mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;::iterator it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">a 1</span><br><span class="hljs-comment">b 3</span><br><span class="hljs-comment">c 2</span><br><span class="hljs-comment">map会在插入过程中会实现从小到大的自动排序。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="3）map-的常用方法"><a href="#3）map-的常用方法" class="headerlink" title="3）map 的常用方法"></a>3）map 的常用方法</h4><ul><li><p><code>insert()</code></p><p>实现 map 的插入有多种方法。</p><ul><li><p>直接下标添加</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mp[key] <span class="hljs-operator">=</span> value<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>insert()</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(kry, value));<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>find()</code>：<code>find(key)</code>返回键为 key 的映射的<strong>迭代器</strong>，时间复杂度为 $O(N)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>    mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">1</span>, mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">2</span>, mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">3</span>;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;::iterator it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>erase()</code>：map 删除函数</p><ul><li><p>删除单个元素</p><ul><li><p><code>mp.erase(it)</code>：it 为所需删除元素的迭代器。时间复杂度为 $O(1)$。</p></li><li><p><code>mp.erase(key)</code>：key 为所需要删除的映射的键。时间复杂度为 $O(logN)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>    mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">1</span>, mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">2</span>, mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">3</span>, mp[<span class="hljs-string">&#x27;d&#x27;</span>] = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 迭代器方式删除</span><br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;::iterator it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    mp.<span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-comment">// key值法删除</span><br>    mp.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;::iterator itt = mp.<span class="hljs-built_in">begin</span>(); itt != mp.<span class="hljs-built_in">end</span>(); itt++) &#123;<br>        cout &lt;&lt; itt-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itt-&gt;second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>删除一个区间内的所有元素</p><p><code>mp.erase(first, last)</code>：删除<code>[first, last)</code>内的所有元素。其中 first 为所需要删除区间的起始迭代器，last 为所需要删除区间的末尾迭代器的下一个地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>    mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">1</span>, mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">2</span>, mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">3</span>, mp[<span class="hljs-string">&#x27;d&#x27;</span>] = <span class="hljs-number">4</span>;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;::iterator it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;c&#x27;</span>);<br>    mp.<span class="hljs-built_in">erase</span>(it, mp.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;::iterator itt = mp.<span class="hljs-built_in">begin</span>(); itt != mp.<span class="hljs-built_in">end</span>(); itt++) &#123;<br>        cout &lt;&lt; itt-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; itt-&gt;second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>size()</code>：返回 map 中映射的对数。时间复杂度为 $O(1)$。</p></li><li><p><code>clear()</code>：清空 map 中的所有元素，时间复杂度为 $O(N)$。</p></li></ul><h3 id="2-5、queue"><a href="#2-5、queue" class="headerlink" title="2.5、queue"></a>2.5、queue</h3><p>queue：队列，是一种<strong>先进先出（FIFO）</strong>的容器，只能访问其第一个和最后一个元素。</p><p>queue 模板类需要两个模板参数，一个是元素类型，一个是容器类型，元素类型必要，容器类型可选，默认是 deque 类型（双端队列）</p><h4 id="1）queue-的定义和初始化"><a href="#1）queue-的定义和初始化" class="headerlink" title="1）queue 的定义和初始化"></a>1）queue 的定义和初始化</h4><p>使用前需要引入头文件<code>#include &lt;queue&gt;</code>。</p><h5 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-keyword">typename</span>&gt; myQueue;<br></code></pre></td></tr></table></figure><h5 id="（2）初始化"><a href="#（2）初始化" class="headerlink" title="（2）初始化"></a>（2）初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">queue&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-title">myQueue</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">// 队列初始化三个元素，都是100</span><br><span class="hljs-function">queue&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-title">tempQueue</span><span class="hljs-params">(myQueue)</span></span>; <span class="hljs-comment">// 复制myQueue的内容初始化队列</span><br></code></pre></td></tr></table></figure><h4 id="2）queue-容器内元素的访问"><a href="#2）queue-容器内元素的访问" class="headerlink" title="2）queue 容器内元素的访问"></a>2）queue 容器内元素的访问</h4><p>由于 queue 具有 FIFO 的特性，属于限制性容器，只能访问第一个和最后一个元素，因此在 STL 中只能通过<code>front()</code>访问队首元素，<code>back()</code>访问队尾元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; myQueue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        myQueue.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    cout &lt;&lt; myQueue.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; myQueue.<span class="hljs-built_in">back</span>() &lt;&lt; endl; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）queue-的常用函数"><a href="#3）queue-的常用函数" class="headerlink" title="3）queue 的常用函数"></a>3）queue 的常用函数</h4><ul><li><code>front()</code>：返回队首元素，如果队列为空，返回值是未定义的。</li><li><code>back()</code>：返回队尾元素，如果队列为空，返回值是未定义的。</li><li><code>push(x)</code>：将元素 x 插入队尾。</li><li><code>pop()</code>：弹出队首元素。</li><li><code>size()</code>：返回 queue 内元素的个数。</li><li><code>empty()</code>：判断 queue 是否为空，为空返回 true，否则返回 false。</li></ul><h4 id="4）queue-的遍历"><a href="#4）queue-的遍历" class="headerlink" title="4）queue 的遍历"></a>4）queue 的遍历</h4><p>和 stack 一样，queue 由于是限制性容器，只允许访问队首和队尾，因此不具有迭代器。遍历容器的唯一方式是访问元素并弹出访问过的每一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; myQueue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        myQueue.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; myQueue.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> val = myQueue.<span class="hljs-built_in">front</span>();<br>        myQueue.<span class="hljs-built_in">pop</span>();<br>        myQueue.<span class="hljs-built_in">push</span>(val);<br>        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5）priority-queue"><a href="#5）priority-queue" class="headerlink" title="5）priority_queue"></a>5）priority_queue</h4><p>在<code>&lt;queue&gt;</code>的头文件中，定义了一个使用的模板类：<code>priority_queue（优先队列）</code>。</p><p>优先队列与普通队列的区别在于优先队列不按照入队的先后顺序出队，而是按照队列中元素的优先权顺序出队（默认大数优先，同时可以通过指定算子来指定自己的优先顺序）。</p><ul><li>优先队列的底层设计是<strong>堆</strong>。</li><li>在优先队列中，队首的优先级最高，队尾最低。在往优先队列添加元素的过程中，堆会即时调整结构，以保证队首元素总是优先级最高。</li><li>priority_queue 有三个模板参数，第一个是元素类型，第二个是容器类型，第三个是比较算子。其中后面两个可以省略，默认容器为 vector，默认算子为 less（大顶堆，越大优先级越高）。</li></ul><h5 id="（1）priority-queue-的定义和初始化"><a href="#（1）priority-queue-的定义和初始化" class="headerlink" title="（1）priority_queue 的定义和初始化"></a>（1）priority_queue 的定义和初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; q1;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt;q2; <span class="hljs-comment">// 两个尖括号之间有空格</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt;q3; <span class="hljs-comment">// 两个尖括号之间有空格</span><br></code></pre></td></tr></table></figure><h5 id="（2）priority-queue-容器中元素的访问"><a href="#（2）priority-queue-容器中元素的访问" class="headerlink" title="（2）priority_queue 容器中元素的访问"></a>（2）priority_queue 容器中元素的访问</h5><p>在优先队列中，没有<code>front()</code>和<code>back()</code>函数，只能通过<code>top()</code>函数来访问队首元素（也可称为堆顶元素），即优先级最高的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; myQueue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        myQueue.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!myQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; myQueue.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        myQueue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（3）priority-queue-常用函数"><a href="#（3）priority-queue-常用函数" class="headerlink" title="（3）priority_queue 常用函数"></a>（3）priority_queue 常用函数</h5><ul><li><p><code>push(x)</code>：将 x 插入优先队列。时间复杂度为 $O(logN)$。</p></li><li><p><code>top()</code>：返回队首元素（即堆顶元素）。时间复杂度为 $O(1)$。</p></li><li><p><code>pop()</code>：令队首元素出队。时间复杂度为 $O(logN)$。</p></li><li><p><code>size()</code>：返回 priority_queue 内元素的个数。</p></li><li><p><code>empty()</code>：判断 priority_queue 是否为空，为空返回 true，否则返回 false。</p></li></ul><h5 id="（4）priority-queue-内元素优先级的定义"><a href="#（4）priority-queue-内元素优先级的定义" class="headerlink" title="（4）priority_queue 内元素优先级的定义"></a>（4）priority_queue 内元素优先级的定义</h5><h6 id="（4-1）基本数据类型的优先级定义"><a href="#（4-1）基本数据类型的优先级定义" class="headerlink" title="（4.1）基本数据类型的优先级定义"></a>（4.1）基本数据类型的优先级定义</h6><p>优先队列默认的优先级算子是 less，即大顶堆（数字越大优先级越高）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 如下两种定义方式等价</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; q1;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt; &gt;q2;<br></code></pre></td></tr></table></figure><ul><li><code>vector&lt;int&gt;</code>表示容器类型。</li><li><code>less&lt;int&gt;</code>表示第一个参数的比较类，<code>less&lt;int&gt;</code>代表大顶堆，<code>greater&lt;int&gt;</code>代表小顶堆。</li></ul><h6 id="（4-2）结构体的优先级定义"><a href="#（4-2）结构体的优先级定义" class="headerlink" title="（4.2）结构体的优先级定义"></a>（4.2）结构体的优先级定义</h6><p>对于结构体优先级的定义，需要重载运算符号，对已有的运算符号进行重新定义。</p><p><strong>重载<code>&gt;</code>会发生编译错误，需要重载<code>&lt;</code></strong></p><ul><li><p>方式一：</p><blockquote><p><strong>示例：一些水果，价格高则优先级高</strong>    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fruit</span> &#123;<br> string name;<br> <span class="hljs-type">double</span> price;<br> <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(fruit f1, fruit f2)<br> &#123;<br>     <span class="hljs-keyword">return</span> f1.price &lt; f2.price;<br> &#125;<br>&#125; f1, f2, f3;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> priority_queue&lt;fruit&gt; q;<br> f1.name = <span class="hljs-string">&quot;桃子&quot;</span>, f1.price = <span class="hljs-number">3</span>;<br> f2.name = <span class="hljs-string">&quot;苹果&quot;</span>, f2.price = <span class="hljs-number">4</span>;<br> f3.name = <span class="hljs-string">&quot;梨&quot;</span>, f3.price = <span class="hljs-number">1</span>;<br> q.<span class="hljs-built_in">push</span>(f1), q.<span class="hljs-built_in">push</span>(f2), q.<span class="hljs-built_in">push</span>(f3);<br> cout &lt;&lt; q.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">top</span>().price &lt;&lt; endl;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>方式二：</p><blockquote><p><strong>示例：一些水果，价格高则优先级高</strong>    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fruit</span> &#123;<br> string name;<br> <span class="hljs-type">double</span> price;<br>&#125;f1, f2, f3;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(fruit f1, fruit f2)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> f1.price &lt; f2.price;<br>&#125;  <br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; &gt; q;<br> f1.name = <span class="hljs-string">&quot;桃子&quot;</span>, f1.price = <span class="hljs-number">3</span>;<br> f2.name = <span class="hljs-string">&quot;苹果&quot;</span>, f2.price = <span class="hljs-number">4</span>;<br> f3.name = <span class="hljs-string">&quot;梨&quot;</span>, f3.price = <span class="hljs-number">1</span>;<br> q.<span class="hljs-built_in">push</span>(f1), q.<span class="hljs-built_in">push</span>(f2), q.<span class="hljs-built_in">push</span>(f3);<br> cout &lt;&lt; q.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; q.<span class="hljs-built_in">top</span>().price &lt;&lt; endl;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>可以通过使用引用来提高效率，具体写法为在比较类的参数中加上<code>const</code>和<code>&amp;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> fruit &amp;f1, <span class="hljs-type">const</span> fruit &amp;f2) &#123;<br>    <span class="hljs-keyword">return</span> f1.price &lt; f2.price;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> fruit &amp;f1, <span class="hljs-type">const</span> fruit &amp;f2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f1.price &lt; f2.price;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-6、stack"><a href="#2-6、stack" class="headerlink" title="2.6、stack"></a>2.6、stack</h3><p>stack：栈，是一个<strong>先进后出（LIFO)</strong>的容器。定义在<code>&lt;stack&gt;</code>头文件中。</p><ul><li>stack 模板类需要两个模板参数，一个是元素类型，一个是容器类型，元素类型是必要的。</li></ul><h4 id="1）stack-的定义和初始化"><a href="#1）stack-的定义和初始化" class="headerlink" title="1）stack 的定义和初始化"></a>1）stack 的定义和初始化</h4><p>使用 stack 需要添加头文件<code>#include &lt;stack&gt;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-keyword">typename</span>&gt; stk;<br></code></pre></td></tr></table></figure><h4 id="2）stack-容器内元素的访问"><a href="#2）stack-容器内元素的访问" class="headerlink" title="2）stack 容器内元素的访问"></a>2）stack 容器内元素的访问</h4><p>由于栈是 LIFO 的限制性容器，因此在 STL 中，栈只能通过<code>top()</code>来访问栈顶元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        stk.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    cout &lt;&lt; stk.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）stack-常用函数"><a href="#3）stack-常用函数" class="headerlink" title="3）stack 常用函数"></a>3）stack 常用函数</h4><ul><li><code>top()</code>：返回栈顶元素。时间复杂度为 $O(1)$。</li><li><code>push(x)</code>：将 x 插入栈。时间复杂度为 $O(1)$。</li><li><code>pop()</code>：弹出栈顶元素。时间复杂度为 $O(1)$。</li></ul><h3 id="2-7、pair"><a href="#2-7、pair" class="headerlink" title="2.7、pair"></a>2.7、pair</h3><p>pair 是将两个数据整合为一组数据，是一种模板类型，其中包含两个数据值，并且两个数据的类型可以不同。</p><ul><li><p>pair 的类模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">T1: 第一个值的数据类型</span><br><span class="hljs-comment">T2: 第二个值的数据类型</span><br><span class="hljs-comment">使用：</span><br><span class="hljs-comment">两个值可以分别用pair的两个公有函数first和second访问。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>pair 构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;T1, T2&gt; pr; <span class="hljs-comment">// 创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span><br><span class="hljs-function">pair&lt;T1, T2&gt; <span class="hljs-title">pr</span><span class="hljs-params">(val1, val2)</span></span>;<span class="hljs-comment">//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为val1，second成员初始化为val2。</span><br><span class="hljs-built_in">make_pair</span>(val1, val2); <span class="hljs-comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span><br>p1 &lt; p2; <span class="hljs-comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span><br>p1 == p2; <span class="hljs-comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span><br>p1.first; <span class="hljs-comment">// 返回对象p1中名为first的公有数据成员</span><br>p1.second; <span class="hljs-comment">// 返回对象p1中名为second的公有数据成员</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1）pair-的定义和初始化"><a href="#1）pair-的定义和初始化" class="headerlink" title="1）pair 的定义和初始化"></a>1）pair 的定义和初始化</h4><p>pair 类型定义在头文件<code>#include &lt;utility&gt;</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;string, string&gt; pr;<br>pair&lt;string, <span class="hljs-type">int</span>&gt; pr;<br>pair&lt;string, vector&lt;<span class="hljs-type">int</span>&gt; &gt;pr;<br><span class="hljs-function">pair&lt;string, string&gt; <span class="hljs-title">pr</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;pair_STL&quot;</span>)</span></span>;<br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">pr</span><span class="hljs-params">(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-comment">// 可以直接通过拷贝初始化</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">ano_pr</span><span class="hljs-params">(pr)</span></span>;<br>pair&lt;string, <span class="hljs-type">int</span>&gt; pr = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>由于pair使用繁琐，因此需要定义多个相同类型的 pair 时，可以通过关键字<code>typedef</code>简化声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;string, <span class="hljs-type">int</span>&gt; pair_string_int;<br><span class="hljs-function">pair_string_int <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">pair_string_int <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;Mack&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="2）pair-容器内元素的访问"><a href="#2）pair-容器内元素的访问" class="headerlink" title="2）pair 容器内元素的访问"></a>2）pair 容器内元素的访问</h4><p>pair 通过<code>pair.first</code>和<code>pair.second</code>来实现元素的访问。</p><h3 id="2-8、iterator"><a href="#2-8、iterator" class="headerlink" title="2.8、iterator"></a>2.8、iterator</h3><p>迭代器 iterator 是 C++STL 组件之一，用来<strong>遍历容器</strong>。迭代器一般实现为容器的嵌套类型，在容器内部提供具体的实现。由于迭代器提供了常用的<code>operator!=</code> <code>operator++</code> <code>operator*</code>等运算符的重载函数，迭代器的细节被全部隐藏在这些通用的运算符重载函数里，因此迭代器遍历所有容器的方式是一样的。</p><p>因此迭代器相当于数据结构中的”遍历指针“，也可以把迭代器看作一种泛化的指针。</p><h4 id="1）五种迭代器"><a href="#1）五种迭代器" class="headerlink" title="1）五种迭代器"></a>1）五种迭代器</h4><ul><li>输入迭代器：输入迭代器可用于读取容器中的元素，但是不能保证支持容器的写入操作。输入迭代器需要满足一下条件<ul><li>相等和不等操作符（<code>==</code> <code>!=</code>），比较两个迭代器。</li><li>前置和后置的自增运算（<code>++</code>），使迭代器向前递进指向下一个元素。</li><li>用于读取元素的解引用操作符（<code>*</code>），此操作符只出现在赋值运算的右操作数上。</li><li>箭头操作符（<code>-&gt;</code>），是<code>(*it).member</code>的同义语，对迭代器进行解引用来获取其所关联的对象的的成员。</li></ul></li><li>输出迭代器：输出迭代器可用于向容器写入元素，但不能保证支持读取容器元素。可视为与输入迭代器功能互补的迭代器。输出迭代器要求：<ul><li>前置和后置的自增运算（<code>++</code>），使迭代器向前递进指向下一个元素。</li><li>解引用操作符（<code>*</code>），引操作符只能出现在赋值运算的左操作数上。给解引用的输出迭代器赋值，将该迭代器所指向的元素做写入操作。输出迭代器可以要求每个迭代器的值必须正好写入一次。使用输出迭代器时，对于指定的迭代器应该使用一次<code>*</code>运算，而且只能使用一次。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </li></ul></li><li>前向迭代器：用于读写指定的容器。这类迭代器只会以一个方向遍历序列。前向迭代器支持输入迭代器和输出迭代器提供的所有操作。同时，还支持对同一个元素的多次读写。可以复制前向迭代器来记录序列中的一个位置，以便返回此处。需要前向迭代器的泛型算法包括<code>replace()</code>。</li><li>双向迭代器：从两个方向读写容器。除了提供前向迭代器的全部操作之外，双向迭代器还提供了前置和后置的自减运算（<code>--</code>）。需要使用双向迭代器的泛型算法包括<code>reserve()</code>。所有的标准库容器提供的迭代器都至少达到双向迭代器的要求。</li><li>随机访问迭代器：提供在常量时间内访问容器任意位置的功能。这种迭代器除了支持双向迭代器的所有功能之外，还支持以下操作：<ul><li>关系运算符<code>&lt;</code> ``&lt;=<code></code>&gt;<code></code>&gt;=`，比较两个迭代器的相对位置。</li><li>迭代器和整型数值 n 之间的加法和减法操作符<code>+</code> <code>+=</code> <code>-</code> <code>-=</code>，结果是迭代器在容器中向前（或退后）n 个元素。</li><li>两个迭代器之间的减法操作符<code>--</code>，得到两个迭代器间的距离。</li><li>下标访问符<code>iter[n]</code>，这是<code>*(iter + n)</code>的同义词。</li></ul></li></ul><h4 id="2）STL-中容器的迭代器"><a href="#2）STL-中容器的迭代器" class="headerlink" title="2）STL 中容器的迭代器"></a>2）STL 中容器的迭代器</h4><ul><li><code>vector</code> <code>deque</code> <code>string</code>提供随机访问迭代器。</li><li><code>map</code> <code>set</code> <code>list</code>提供双向迭代器。</li></ul><blockquote><p><strong>特殊：</strong></p><p><code>istream_iterator</code>是输入迭代器。</p><p><code>ostream_iterator</code>是输出迭代器。</p></blockquote><h3 id="2-9、algorithm"><a href="#2-9、algorithm" class="headerlink" title="2.9、algorithm"></a>2.9、algorithm</h3><p><code>&lt;algorithm&gt;</code>是 STL 中最大的一个头文件，是由一大堆模板函数组成的。</p><p>仅仅列出<code>&lt;algorithm&gt;</code>中的模板函数：</p><p><code>adjacent_find</code> <code>binary_search</code> <code>copy</code> <code>copy_backward</code> <code>count</code> <code>count_if</code> <code>equal</code> <code>equal_range</code> <code>fill</code> <code>fill_n</code> <code>find</code> <code>find_end</code> <code>find_first_of</code> <code>find_if</code> <code>for_each</code> <code>generate</code> <code>generate_n</code> <code>includes</code> <code>inplace_merge</code> <code>iter_swap</code> <code>lexicographical_compare</code> <code>lower_bound</code> <code>make_heap</code> <code>max</code> <code>max_element</code> <code>merge</code> <code>min</code> <code>min_element</code> <code>mismatch</code> <code>next_permutation</code> <code>nth_element</code> <code>partial_sort</code> <code>partial_sort_copy</code> <code>partition</code> <code>pop_heap</code> <code>prev_permutation</code> <code>push_heap</code> <code>random_shuffle</code> <code>remove</code> <code>remove_copy</code> <code>remove_copy_if</code> <code>remove_if</code> <code>replace</code> <code>replace_copy</code> <code>replace_copy_if</code> <code>replace_if</code> <code>reverse</code> <code>reverse_copy</code> <code>rotate</code> <code>rotate_copy</code> <code>search</code> <code>search_n</code> <code>set_difference</code> <code>set_intersection</code> <code>set_symmetric_difference</code> <code>set_union</code> <code>sort</code> <code>sort_heap</code> <code>stable_partition</code> <code>stable_sort</code> <code>swap</code> <code>swap_ranges</code> <code>transform</code> <code>unique</code> <code>unique_copy</code> <code>upper_bound</code></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>